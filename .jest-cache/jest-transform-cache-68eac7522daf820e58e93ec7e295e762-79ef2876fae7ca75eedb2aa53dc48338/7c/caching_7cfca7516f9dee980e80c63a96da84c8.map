{"version":3,"sources":["/Users/joshszep/code/therobotoverlord-mono/therobotoverlord-web/src/utils/caching.ts"],"sourcesContent":["'use client';\n\nimport React from 'react';\n\n// Cache configuration\ninterface CacheConfig {\n  ttl: number; // Time to live in milliseconds\n  maxSize: number; // Maximum number of items\n  staleWhileRevalidate?: boolean;\n}\n\n// Cache entry interface\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n  ttl: number;\n  hits: number;\n}\n\n// In-memory cache implementation\nclass MemoryCache<T = any> {\n  private cache = new Map<string, CacheEntry<T>>();\n  private config: CacheConfig;\n\n  constructor(config: CacheConfig) {\n    this.config = config;\n  }\n\n  set(key: string, data: T, customTtl?: number): void {\n    const ttl = customTtl || this.config.ttl;\n    \n    // Remove oldest entries if cache is full\n    if (this.cache.size >= this.config.maxSize) {\n      const oldestKey = this.cache.keys().next().value;\n      if (oldestKey) {\n        this.cache.delete(oldestKey);\n      }\n    }\n\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl,\n      hits: 0\n    });\n  }\n\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n    \n    if (!entry) return null;\n\n    const now = Date.now();\n    const isExpired = now - entry.timestamp > entry.ttl;\n\n    if (isExpired) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    // Update hit count\n    entry.hits++;\n    return entry.data;\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key) && this.get(key) !== null;\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  size(): number {\n    return this.cache.size;\n  }\n\n  getStats(): { size: number; hitRate: number; entries: Array<{ key: string; hits: number; age: number }> } {\n    const entries = Array.from(this.cache.entries()).map(([key, entry]) => ({\n      key,\n      hits: entry.hits,\n      age: Date.now() - entry.timestamp\n    }));\n\n    const totalHits = entries.reduce((sum, entry) => sum + entry.hits, 0);\n    const hitRate = entries.length > 0 ? totalHits / entries.length : 0;\n\n    return {\n      size: this.cache.size,\n      hitRate,\n      entries\n    };\n  }\n}\n\n// Browser storage cache implementation\nclass StorageCache<T = any> {\n  private storage: Storage;\n  private prefix: string;\n  private config: CacheConfig;\n\n  constructor(storage: Storage, prefix: string, config: CacheConfig) {\n    this.storage = storage;\n    this.prefix = prefix;\n    this.config = config;\n  }\n\n  private getKey(key: string): string {\n    return `${this.prefix}:${key}`;\n  }\n\n  set(key: string, data: T, customTtl?: number): void {\n    const ttl = customTtl || this.config.ttl;\n    const entry: CacheEntry<T> = {\n      data,\n      timestamp: Date.now(),\n      ttl,\n      hits: 0\n    };\n\n    try {\n      this.storage.setItem(this.getKey(key), JSON.stringify(entry));\n    } catch (error) {\n      // Handle storage quota exceeded\n      console.warn('Cache storage full, clearing old entries');\n      this.cleanup();\n      try {\n        this.storage.setItem(this.getKey(key), JSON.stringify(entry));\n      } catch {\n        console.error('Unable to cache data');\n      }\n    }\n  }\n\n  get(key: string): T | null {\n    try {\n      const item = this.storage.getItem(this.getKey(key));\n      if (!item) return null;\n\n      const entry: CacheEntry<T> = JSON.parse(item);\n      const now = Date.now();\n      const isExpired = now - entry.timestamp > entry.ttl;\n\n      if (isExpired) {\n        this.storage.removeItem(this.getKey(key));\n        return null;\n      }\n\n      // Update hit count\n      entry.hits++;\n      this.storage.setItem(this.getKey(key), JSON.stringify(entry));\n      \n      return entry.data;\n    } catch {\n      return null;\n    }\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== null;\n  }\n\n  delete(key: string): boolean {\n    this.storage.removeItem(this.getKey(key));\n    return true;\n  }\n\n  clear(): void {\n    const keys = Object.keys(this.storage).filter(key => key.startsWith(this.prefix));\n    keys.forEach(key => this.storage.removeItem(key));\n  }\n\n  private cleanup(): void {\n    const keys = Object.keys(this.storage).filter(key => key.startsWith(this.prefix));\n    const entries = keys.map(key => {\n      try {\n        const item = this.storage.getItem(key);\n        const entry = item ? JSON.parse(item) : null;\n        return { key, entry };\n      } catch {\n        return { key, entry: null };\n      }\n    }).filter(({ entry }) => entry !== null);\n\n    // Remove expired entries first\n    const now = Date.now();\n    entries.forEach(({ key, entry }) => {\n      if (entry && now - entry.timestamp > entry.ttl) {\n        this.storage.removeItem(key);\n      }\n    });\n\n    // If still over limit, remove least recently used\n    const remainingKeys = Object.keys(this.storage).filter(key => key.startsWith(this.prefix));\n    if (remainingKeys.length > this.config.maxSize) {\n      const sortedEntries = entries\n        .filter(({ key }) => remainingKeys.includes(key))\n        .sort((a, b) => (a.entry?.hits || 0) - (b.entry?.hits || 0));\n      \n      const toRemove = sortedEntries.slice(0, remainingKeys.length - this.config.maxSize);\n      toRemove.forEach(({ key }) => this.storage.removeItem(key));\n    }\n  }\n}\n\n// Cache factory\nexport const createCache = <T = any>(\n  type: 'memory' | 'localStorage' | 'sessionStorage',\n  config: CacheConfig,\n  prefix = 'robot-overlord'\n) => {\n  switch (type) {\n    case 'memory':\n      return new MemoryCache<T>(config);\n    case 'localStorage':\n      if (typeof window !== 'undefined') {\n        return new StorageCache<T>(localStorage, prefix, config);\n      }\n      return new MemoryCache<T>(config);\n    case 'sessionStorage':\n      if (typeof window !== 'undefined') {\n        return new StorageCache<T>(sessionStorage, prefix, config);\n      }\n      return new MemoryCache<T>(config);\n    default:\n      return new MemoryCache<T>(config);\n  }\n};\n\n// Predefined caches for different use cases\nexport const apiCache = createCache('memory', {\n  ttl: 5 * 60 * 1000, // 5 minutes\n  maxSize: 100,\n  staleWhileRevalidate: true\n});\n\nexport const userDataCache = createCache('localStorage', {\n  ttl: 30 * 60 * 1000, // 30 minutes\n  maxSize: 50\n});\n\nexport const sessionCache = createCache('sessionStorage', {\n  ttl: 60 * 60 * 1000, // 1 hour\n  maxSize: 200\n});\n\nexport const staticDataCache = createCache('localStorage', {\n  ttl: 24 * 60 * 60 * 1000, // 24 hours\n  maxSize: 20\n});\n\n// Cache decorator for functions\nexport const withCache = <T extends (...args: any[]) => any>(\n  fn: T,\n  cache: MemoryCache | StorageCache,\n  keyGenerator?: (...args: Parameters<T>) => string\n): T => {\n  return ((...args: Parameters<T>) => {\n    const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);\n    \n    // Try to get from cache first\n    const cached = cache.get(key);\n    if (cached !== null) {\n      return cached;\n    }\n\n    // Execute function and cache result\n    const result = fn(...args);\n    \n    // Handle promises\n    if (result instanceof Promise) {\n      return result.then(data => {\n        cache.set(key, data);\n        return data;\n      });\n    }\n\n    cache.set(key, result);\n    return result;\n  }) as T;\n};\n\n// React hook for caching\nexport const useCache = <T>(\n  key: string,\n  fetcher: () => Promise<T> | T,\n  options: {\n    cache?: MemoryCache<T> | StorageCache<T>;\n    ttl?: number;\n    enabled?: boolean;\n  } = {}\n) => {\n  const {\n    cache = apiCache,\n    ttl,\n    enabled = true\n  } = options;\n\n  const [data, setData] = React.useState<T | null>(null);\n  const [loading, setLoading] = React.useState(false);\n  const [error, setError] = React.useState<Error | null>(null);\n\n  React.useEffect(() => {\n    if (!enabled) return;\n\n    const fetchData = async () => {\n      // Try cache first\n      const cached = cache.get(key);\n      if (cached !== null) {\n        setData(cached);\n        return;\n      }\n\n      setLoading(true);\n      setError(null);\n\n      try {\n        const result = await fetcher();\n        cache.set(key, result, ttl);\n        setData(result);\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error('Unknown error'));\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [key, enabled, cache, ttl, fetcher]);\n\n  const invalidate = React.useCallback(() => {\n    cache.delete(key);\n    setData(null);\n  }, [cache, key]);\n\n  const refresh = React.useCallback(async () => {\n    cache.delete(key);\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await fetcher();\n      cache.set(key, result, ttl);\n      setData(result);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Unknown error'));\n    } finally {\n      setLoading(false);\n    }\n  }, [cache, key, fetcher, ttl]);\n\n  return {\n    data,\n    loading,\n    error,\n    invalidate,\n    refresh\n  };\n};\n\n// Service Worker cache strategies (for production)\nexport const registerServiceWorker = () => {\n  if (typeof window !== 'undefined' && 'serviceWorker' in navigator) {\n    window.addEventListener('load', () => {\n      navigator.serviceWorker.register('/sw.js')\n        .then(registration => {\n          console.log('SW registered: ', registration);\n        })\n        .catch(registrationError => {\n          console.log('SW registration failed: ', registrationError);\n        });\n    });\n  }\n};\n\nexport default {\n  createCache,\n  withCache,\n  useCache,\n  apiCache,\n  userDataCache,\n  sessionCache,\n  staticDataCache,\n  registerServiceWorker\n};\n"],"names":["apiCache","createCache","registerServiceWorker","sessionCache","staticDataCache","useCache","userDataCache","withCache","MemoryCache","config","cache","Map","set","key","data","customTtl","ttl","size","maxSize","oldestKey","keys","next","value","delete","timestamp","Date","now","hits","get","entry","isExpired","has","clear","getStats","entries","Array","from","map","age","totalHits","reduce","sum","hitRate","length","StorageCache","storage","prefix","getKey","setItem","JSON","stringify","error","console","warn","cleanup","item","getItem","parse","removeItem","Object","filter","startsWith","forEach","remainingKeys","sortedEntries","includes","sort","a","b","toRemove","slice","type","window","localStorage","sessionStorage","staleWhileRevalidate","fn","keyGenerator","args","cached","result","Promise","then","fetcher","options","enabled","setData","React","useState","loading","setLoading","setError","useEffect","fetchData","err","Error","invalidate","useCallback","refresh","navigator","addEventListener","serviceWorker","register","registration","log","catch","registrationError"],"mappings":"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"}