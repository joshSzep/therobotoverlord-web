5a365bc305af107f4c5b044873a5fd07
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock WebSocket
const MockWebSocketInstances = [];
class MockWebSocket {
    static{
        this.CONNECTING = 0;
    }
    static{
        this.OPEN = 1;
    }
    static{
        this.CLOSING = 2;
    }
    static{
        this.CLOSED = 3;
    }
    constructor(url){
        this.readyState = MockWebSocket.CONNECTING;
        this.onopen = null;
        this.onclose = null;
        this.onmessage = null;
        this.onerror = null;
        this.url = url;
        MockWebSocketInstances.push(this);
        // Simulate connection opening
        setTimeout(()=>{
            this.readyState = MockWebSocket.OPEN;
            if (this.onopen) {
                this.onopen(new Event('open'));
            }
        }, 10);
    }
    send(data) {
        if (this.readyState !== MockWebSocket.OPEN) {
            throw new Error('WebSocket is not open');
        }
        // Echo back for testing
        setTimeout(()=>{
            if (this.onmessage) {
                this.onmessage(new MessageEvent('message', {
                    data
                }));
            }
        }, 50);
    }
    close() {
        this.readyState = MockWebSocket.CLOSED;
        if (this.onclose) {
            this.onclose(new CloseEvent('close'));
        }
    }
    // Test helpers
    simulateMessage(data) {
        if (this.onmessage && this.readyState === MockWebSocket.OPEN) {
            // Trigger immediately for tests
            this.onmessage(new MessageEvent('message', {
                data: typeof data === 'string' ? data : JSON.stringify(data)
            }));
        }
    }
    simulateError() {
        if (this.onerror) {
            this.onerror(new Event('error'));
        }
    }
    simulateClose() {
        this.readyState = MockWebSocket.CLOSED;
        if (this.onclose) {
            this.onclose(new CloseEvent('close'));
        }
    }
}
// Create a Jest mock for WebSocket constructor
const MockWebSocketConstructor = jest.fn().mockImplementation((url)=>{
    return new MockWebSocket(url);
});
// Replace global WebSocket with mock
global.WebSocket = MockWebSocketConstructor;
// Mock WebSocket context and provider
const MockWebSocketProvider = ({ children })=>{
    const [socket, setSocket] = _react.default.useState(null);
    const [isConnected, setIsConnected] = _react.default.useState(false);
    const [connectionStatus, setConnectionStatus] = _react.default.useState('disconnected');
    const connect = _react.default.useCallback(()=>{
        if (socket) return;
        const ws = new global.WebSocket('ws://localhost:3001');
        ws.onopen = ()=>{
            setIsConnected(true);
            setConnectionStatus('connected');
        };
        ws.onclose = ()=>{
            setIsConnected(false);
            setConnectionStatus('disconnected');
            setSocket(null);
        };
        ws.onerror = ()=>{
            setConnectionStatus('disconnected');
            setIsConnected(false);
        };
        setSocket(ws);
        setConnectionStatus('connecting');
        // Simulate connection opening after a brief delay
        setTimeout(()=>{
            if (ws.onopen) ws.onopen(new Event('open'));
        }, 10);
    }, [
        socket
    ]);
    // Auto-connect on mount
    _react.default.useEffect(()=>{
        connect();
    }, [
        connect
    ]);
    const disconnect = _react.default.useCallback(()=>{
        if (socket) {
            socket.close();
        }
    }, [
        socket
    ]);
    const sendMessage = _react.default.useCallback((message)=>{
        if (socket && isConnected) {
            socket.send(JSON.stringify(message));
        }
    }, [
        socket,
        isConnected
    ]);
    _react.default.useEffect(()=>{
        connect();
        return ()=>disconnect();
    }, [
        connect,
        disconnect
    ]);
    const contextValue = {
        socket,
        isConnected,
        connectionStatus,
        connect,
        disconnect,
        sendMessage
    };
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        "data-testid": "websocket-provider",
        children: _react.default.Children.map(children, (child)=>/*#__PURE__*/ _react.default.isValidElement(child) ? /*#__PURE__*/ _react.default.cloneElement(child, {
                ...contextValue
            }) : child)
    });
};
// Mock real-time chat component
const MockChatComponent = ({ socket, isConnected, connectionStatus, sendMessage })=>{
    const [messages, setMessages] = _react.default.useState([]);
    const [inputValue, setInputValue] = _react.default.useState('');
    _react.default.useEffect(()=>{
        if (!socket) return;
        const handleMessage = (event)=>{
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'message') {
                    setMessages((prev)=>[
                            ...prev,
                            data.payload
                        ]);
                }
            } catch (error) {
                console.error('Failed to parse message:', error);
            }
        };
        socket.onmessage = handleMessage;
        return ()=>{
            if (socket.onmessage === handleMessage) {
                socket.onmessage = null;
            }
        };
    }, [
        socket
    ]);
    const handleSendMessage = ()=>{
        if (inputValue.trim() && isConnected) {
            const message = {
                type: 'message',
                payload: {
                    id: Date.now().toString(),
                    content: inputValue,
                    author: 'testuser',
                    timestamp: new Date().toISOString()
                }
            };
            sendMessage(message);
            setInputValue('');
        }
    };
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
        "data-testid": "chat-component",
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                "data-testid": "connection-status",
                children: [
                    "Status: ",
                    connectionStatus
                ]
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "messages-container",
                children: messages.map((msg)=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                        "data-testid": `message-${msg.id}`,
                        children: [
                            /*#__PURE__*/ (0, _jsxruntime.jsxs)("strong", {
                                children: [
                                    msg.author,
                                    ":"
                                ]
                            }),
                            " ",
                            msg.content
                        ]
                    }, msg.id))
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                "data-testid": "message-input-container",
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("input", {
                        "data-testid": "message-input",
                        value: inputValue,
                        onChange: (e)=>setInputValue(e.target.value),
                        onKeyPress: (e)=>e.key === 'Enter' && handleSendMessage(),
                        disabled: !isConnected,
                        placeholder: isConnected ? 'Type a message...' : 'Connecting...'
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                        "data-testid": "send-button",
                        onClick: handleSendMessage,
                        disabled: !isConnected || !inputValue.trim(),
                        children: "Send"
                    })
                ]
            })
        ]
    });
};
// Mock live updates component
const MockLiveUpdatesComponent = ({ socket, isConnected })=>{
    const [posts, setPosts] = _react.default.useState([]);
    const [notifications, setNotifications] = _react.default.useState([]);
    _react.default.useEffect(()=>{
        if (!socket) return;
        const handleMessage = (event)=>{
            try {
                let data;
                if (typeof event.data === 'string') {
                    data = JSON.parse(event.data);
                } else {
                    data = event.data;
                }
                switch(data.type){
                    case 'new_post':
                        setPosts((prev)=>[
                                data.payload,
                                ...prev
                            ]);
                        break;
                    case 'post_updated':
                        setPosts((prev)=>prev.map((post)=>post.id === data.payload.id ? data.payload : post));
                        break;
                    case 'notification':
                        setNotifications((prev)=>[
                                data.payload,
                                ...prev
                            ]);
                        break;
                }
            } catch (error) {
                console.error('Failed to parse live update:', error);
            }
        };
        socket.onmessage = handleMessage;
        return ()=>{
            if (socket.onmessage === handleMessage) {
                socket.onmessage = null;
            }
        };
    }, [
        socket
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
        "data-testid": "live-updates",
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "live-posts",
                children: posts.map((post)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": `live-post-${post.id}`,
                        children: post.title
                    }, post.id))
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "live-notifications",
                children: notifications.map((notification)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": `notification-${notification.id}`,
                        children: notification.message
                    }, notification.id))
            })
        ]
    });
};
describe('WebSocket Integration Tests', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        MockWebSocketInstances.length = 0;
    });
    describe('Connection Management', ()=>{
        it('establishes WebSocket connection on mount', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "test-component"
                })
            }));
            expect(_react1.screen.getByTestId('websocket-provider')).toBeInTheDocument();
            // Wait for connection to establish
            await (0, _react1.waitFor)(()=>{
                // Connection should be established automatically
                expect(MockWebSocketConstructor).toHaveBeenCalledWith('ws://localhost:3001');
            }, {
                timeout: 200
            });
        });
        it('shows connection status changes', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MockChatComponent, {})
            }));
            // Initially connecting
            expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connecting');
            // Wait for connection to open
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connected');
            }, {
                timeout: 200
            });
        });
        it('handles connection errors', async ()=>{
            const TestComponent = ({ socket })=>{
                const [error, setError] = _react.default.useState('');
                _react.default.useEffect(()=>{
                    if (socket) {
                        socket.onerror = ()=>setError('Connection failed');
                    }
                }, [
                    socket
                ]);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    children: error && /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": "connection-error",
                        children: error
                    })
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {})
            }));
            // Wait for socket to be created, then simulate error
            await (0, _react1.waitFor)(()=>{
                const provider = _react1.screen.getByTestId('websocket-provider');
                expect(provider).toBeInTheDocument();
            });
            // Simulate connection error
            await (0, _react1.act)(async ()=>{
                // This would be triggered by the mock WebSocket
                const mockSocket = new MockWebSocket('ws://localhost:3001');
                mockSocket.simulateError();
            });
        });
        it('reconnects on connection loss', async ()=>{
            const TestComponent = ({ socket, connect, connectionStatus })=>{
                _react.default.useEffect(()=>{
                    if (connectionStatus === 'disconnected' && !socket) {
                        // Auto-reconnect logic
                        setTimeout(connect, 1000);
                    }
                }, [
                    connectionStatus,
                    socket,
                    connect
                ]);
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    "data-testid": "connection-status",
                    children: [
                        "Status: ",
                        connectionStatus
                    ]
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {})
            }));
            // Wait for initial connection
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connected');
            });
            // Simulate connection loss
            await (0, _react1.act)(async ()=>{
                const mockSocket = new MockWebSocket('ws://localhost:3001');
                mockSocket.simulateClose();
            });
        });
    });
    describe('Real-time Chat', ()=>{
        it('sends and receives chat messages', async ()=>{
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MockChatComponent, {})
            }));
            // Wait for connection
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connected');
            });
            // Type and send message
            const input = _react1.screen.getByTestId('message-input');
            const sendButton = _react1.screen.getByTestId('send-button');
            await user.type(input, 'Hello, world!');
            await user.click(sendButton);
            // Message should be sent and echoed back
            await (0, _react1.waitFor)(()=>{
                const messagesContainer = _react1.screen.getByTestId('messages-container');
                expect(messagesContainer.children.length).toBeGreaterThan(0);
                expect(_react1.screen.getByText('testuser:')).toBeInTheDocument();
                expect(_react1.screen.getByText('Hello, world!')).toBeInTheDocument();
            });
            // Input should be cleared
            expect(input).toHaveValue('');
        });
        it('disables input when disconnected', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MockChatComponent, {})
            }));
            const input = _react1.screen.getByTestId('message-input');
            const sendButton = _react1.screen.getByTestId('send-button');
            // Initially disabled while connecting
            expect(input).toBeDisabled();
            expect(sendButton).toBeDisabled();
            // Wait for connection
            await (0, _react1.waitFor)(()=>{
                expect(input).not.toBeDisabled();
                expect(sendButton).toBeDisabled(); // Still disabled due to empty input
            });
        });
        it('handles message sending with Enter key', async ()=>{
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MockChatComponent, {})
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connected');
            });
            const input = _react1.screen.getByTestId('message-input');
            await user.type(input, 'Test message{enter}');
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('Test message')).toBeInTheDocument();
            });
        });
    });
    describe('Live Updates', ()=>{
        it('receives and displays new posts', async ()=>{
            let testSocket = null;
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    testSocket = ws;
                    setSocket(ws);
                    // Wait for connection to open, then simulate message
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            ws.simulateMessage({
                                type: 'new_post',
                                payload: {
                                    id: '1',
                                    title: 'Live Post Update',
                                    content: 'Test content',
                                    author: 'testuser'
                                }
                            });
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('Live Post Update')).toBeInTheDocument();
            }, {
                timeout: 2000
            });
        });
        it('receives and displays notifications', async ()=>{
            let testSocket = null;
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    testSocket = ws;
                    setSocket(ws);
                    // Wait for connection to open, then simulate message
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            ws.simulateMessage({
                                type: 'notification',
                                payload: {
                                    id: '1',
                                    message: 'New notification received'
                                }
                            });
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('New notification received')).toBeInTheDocument();
            }, {
                timeout: 2000
            });
        });
        it('updates existing posts when modified', async ()=>{
            let testSocket = null;
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    testSocket = ws;
                    setSocket(ws);
                    // Wait for connection to open, then simulate messages
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            // First, add a post
                            ws.simulateMessage({
                                type: 'new_post',
                                payload: {
                                    id: '1',
                                    title: 'Original Title',
                                    content: 'Original content',
                                    author: 'testuser'
                                }
                            });
                            // Then update it
                            setTimeout(()=>{
                                ws.simulateMessage({
                                    type: 'post_updated',
                                    payload: {
                                        id: '1',
                                        title: 'Updated Title',
                                        content: 'Updated content',
                                        author: 'testuser'
                                    }
                                });
                            }, 10);
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Wait for original post
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('Original Title')).toBeInTheDocument();
            }, {
                timeout: 2000
            });
            // Wait for update
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('Updated Title')).toBeInTheDocument();
                expect(_react1.screen.queryByText('Original Title')).not.toBeInTheDocument();
            }, {
                timeout: 1000
            });
        });
    });
    describe('Error Handling', ()=>{
        it('handles malformed WebSocket messages', async ()=>{
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    setSocket(ws);
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN && ws.onmessage) {
                            // Send malformed JSON
                            ws.onmessage(new MessageEvent('message', {
                                data: 'invalid json'
                            }));
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(consoleSpy).toHaveBeenCalledWith('Failed to parse live update:', expect.any(Error));
            }, {
                timeout: 1000
            });
            consoleSpy.mockRestore();
        });
        it('gracefully handles unknown message types', async ()=>{
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    setSocket(ws);
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            ws.simulateMessage({
                                type: 'unknown_type',
                                payload: {
                                    data: 'test'
                                }
                            });
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Should not crash or show any error
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('live-updates')).toBeInTheDocument();
            });
        });
    });
    describe('Performance', ()=>{
        it('handles high-frequency messages without performance issues', async ()=>{
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    setSocket(ws);
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            // Send many messages rapidly
                            for(let i = 0; i < 10; i++){
                                ws.simulateMessage({
                                    type: 'notification',
                                    payload: {
                                        id: i.toString(),
                                        message: `Message ${i}`,
                                        type: 'info'
                                    }
                                });
                            }
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            const startTime = performance.now();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Wait for messages to be processed
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getAllByTestId(/notification-/).length).toBeGreaterThanOrEqual(10);
            }, {
                timeout: 3000
            });
            const endTime = performance.now();
            const processingTime = endTime - startTime;
            // Should process messages reasonably quickly
            expect(processingTime).toBeLessThan(3000);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3Noc3plcC9jb2RlL3RoZXJvYm90b3ZlcmxvcmQtbW9uby90aGVyb2JvdG92ZXJsb3JkLXdlYi9zcmMvX190ZXN0c19fL2ludGVncmF0aW9uL3dlYnNvY2tldC5pbnRlZ3JhdGlvbi50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgd2FpdEZvciwgYWN0IH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCdcbmltcG9ydCB1c2VyRXZlbnQgZnJvbSAnQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50J1xuXG4vLyBNb2NrIFdlYlNvY2tldFxuY29uc3QgTW9ja1dlYlNvY2tldEluc3RhbmNlczogTW9ja1dlYlNvY2tldFtdID0gW11cblxuY2xhc3MgTW9ja1dlYlNvY2tldCB7XG4gIHN0YXRpYyBDT05ORUNUSU5HID0gMFxuICBzdGF0aWMgT1BFTiA9IDFcbiAgc3RhdGljIENMT1NJTkcgPSAyXG4gIHN0YXRpYyBDTE9TRUQgPSAzXG5cbiAgdXJsOiBzdHJpbmdcbiAgcmVhZHlTdGF0ZTogbnVtYmVyID0gTW9ja1dlYlNvY2tldC5DT05ORUNUSU5HXG4gIG9ub3BlbjogKChldmVudDogRXZlbnQpID0+IHZvaWQpIHwgbnVsbCA9IG51bGxcbiAgb25jbG9zZTogKChldmVudDogQ2xvc2VFdmVudCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbFxuICBvbm1lc3NhZ2U6ICgoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbFxuICBvbmVycm9yOiAoKGV2ZW50OiBFdmVudCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICBNb2NrV2ViU29ja2V0SW5zdGFuY2VzLnB1c2godGhpcylcbiAgICAvLyBTaW11bGF0ZSBjb25uZWN0aW9uIG9wZW5pbmdcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IE1vY2tXZWJTb2NrZXQuT1BFTlxuICAgICAgaWYgKHRoaXMub25vcGVuKSB7XG4gICAgICAgIHRoaXMub25vcGVuKG5ldyBFdmVudCgnb3BlbicpKVxuICAgICAgfVxuICAgIH0sIDEwKVxuICB9XG5cbiAgc2VuZChkYXRhOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBNb2NrV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuJylcbiAgICB9XG4gICAgLy8gRWNobyBiYWNrIGZvciB0ZXN0aW5nXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5vbm1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UobmV3IE1lc3NhZ2VFdmVudCgnbWVzc2FnZScsIHsgZGF0YSB9KSlcbiAgICAgIH1cbiAgICB9LCA1MClcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IE1vY2tXZWJTb2NrZXQuQ0xPU0VEXG4gICAgaWYgKHRoaXMub25jbG9zZSkge1xuICAgICAgdGhpcy5vbmNsb3NlKG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRlc3QgaGVscGVyc1xuICBzaW11bGF0ZU1lc3NhZ2UoZGF0YTogYW55KSB7XG4gICAgaWYgKHRoaXMub25tZXNzYWdlICYmIHRoaXMucmVhZHlTdGF0ZSA9PT0gTW9ja1dlYlNvY2tldC5PUEVOKSB7XG4gICAgICAvLyBUcmlnZ2VyIGltbWVkaWF0ZWx5IGZvciB0ZXN0c1xuICAgICAgdGhpcy5vbm1lc3NhZ2UobmV3IE1lc3NhZ2VFdmVudCgnbWVzc2FnZScsIHsgXG4gICAgICAgIGRhdGE6IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgfSkpXG4gICAgfVxuICB9XG5cbiAgc2ltdWxhdGVFcnJvcigpIHtcbiAgICBpZiAodGhpcy5vbmVycm9yKSB7XG4gICAgICB0aGlzLm9uZXJyb3IobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgIH1cbiAgfVxuXG4gIHNpbXVsYXRlQ2xvc2UoKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gTW9ja1dlYlNvY2tldC5DTE9TRURcbiAgICBpZiAodGhpcy5vbmNsb3NlKSB7XG4gICAgICB0aGlzLm9uY2xvc2UobmV3IENsb3NlRXZlbnQoJ2Nsb3NlJykpXG4gICAgfVxuICB9XG59XG5cbi8vIENyZWF0ZSBhIEplc3QgbW9jayBmb3IgV2ViU29ja2V0IGNvbnN0cnVjdG9yXG5jb25zdCBNb2NrV2ViU29ja2V0Q29uc3RydWN0b3IgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCh1cmw6IHN0cmluZykgPT4ge1xuICByZXR1cm4gbmV3IE1vY2tXZWJTb2NrZXQodXJsKVxufSlcblxuLy8gUmVwbGFjZSBnbG9iYWwgV2ViU29ja2V0IHdpdGggbW9ja1xuZ2xvYmFsLldlYlNvY2tldCA9IE1vY2tXZWJTb2NrZXRDb25zdHJ1Y3RvciBhcyBhbnlcblxuLy8gTW9jayBXZWJTb2NrZXQgY29udGV4dCBhbmQgcHJvdmlkZXJcbmNvbnN0IE1vY2tXZWJTb2NrZXRQcm92aWRlciA9ICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiB7XG4gIGNvbnN0IFtzb2NrZXQsIHNldFNvY2tldF0gPSBSZWFjdC51c2VTdGF0ZTxNb2NrV2ViU29ja2V0IHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2Nvbm5lY3Rpb25TdGF0dXMsIHNldENvbm5lY3Rpb25TdGF0dXNdID0gUmVhY3QudXNlU3RhdGU8J2Nvbm5lY3RpbmcnIHwgJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJz4oJ2Rpc2Nvbm5lY3RlZCcpXG5cbiAgY29uc3QgY29ubmVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoc29ja2V0KSByZXR1cm5cblxuICAgIGNvbnN0IHdzID0gbmV3IChnbG9iYWwuV2ViU29ja2V0IGFzIGFueSkoJ3dzOi8vbG9jYWxob3N0OjMwMDEnKVxuICAgIFxuICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpXG4gICAgICBzZXRDb25uZWN0aW9uU3RhdHVzKCdjb25uZWN0ZWQnKVxuICAgIH1cblxuICAgIHdzLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSlcbiAgICAgIHNldENvbm5lY3Rpb25TdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpXG4gICAgICBzZXRTb2NrZXQobnVsbClcbiAgICB9XG5cbiAgICB3cy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgc2V0Q29ubmVjdGlvblN0YXR1cygnZGlzY29ubmVjdGVkJylcbiAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKVxuICAgIH1cblxuICAgIHNldFNvY2tldCh3cylcbiAgICBzZXRDb25uZWN0aW9uU3RhdHVzKCdjb25uZWN0aW5nJylcbiAgICBcbiAgICAvLyBTaW11bGF0ZSBjb25uZWN0aW9uIG9wZW5pbmcgYWZ0ZXIgYSBicmllZiBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHdzLm9ub3Blbikgd3Mub25vcGVuKG5ldyBFdmVudCgnb3BlbicpKVxuICAgIH0sIDEwKVxuICB9LCBbc29ja2V0XSlcblxuICAvLyBBdXRvLWNvbm5lY3Qgb24gbW91bnRcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25uZWN0KClcbiAgfSwgW2Nvbm5lY3RdKVxuXG4gIGNvbnN0IGRpc2Nvbm5lY3QgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgc29ja2V0LmNsb3NlKClcbiAgICB9XG4gIH0sIFtzb2NrZXRdKVxuXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gUmVhY3QudXNlQ2FsbGJhY2soKG1lc3NhZ2U6IGFueSkgPT4ge1xuICAgIGlmIChzb2NrZXQgJiYgaXNDb25uZWN0ZWQpIHtcbiAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKVxuICAgIH1cbiAgfSwgW3NvY2tldCwgaXNDb25uZWN0ZWRdKVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29ubmVjdCgpXG4gICAgcmV0dXJuICgpID0+IGRpc2Nvbm5lY3QoKVxuICB9LCBbY29ubmVjdCwgZGlzY29ubmVjdF0pXG5cbiAgY29uc3QgY29udGV4dFZhbHVlID0ge1xuICAgIHNvY2tldCxcbiAgICBpc0Nvbm5lY3RlZCxcbiAgICBjb25uZWN0aW9uU3RhdHVzLFxuICAgIGNvbm5lY3QsXG4gICAgZGlzY29ubmVjdCxcbiAgICBzZW5kTWVzc2FnZVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGRhdGEtdGVzdGlkPVwid2Vic29ja2V0LXByb3ZpZGVyXCI+XG4gICAgICB7UmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiBcbiAgICAgICAgUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpIFxuICAgICAgICAgID8gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7IC4uLmNvbnRleHRWYWx1ZSB9KVxuICAgICAgICAgIDogY2hpbGRcbiAgICAgICl9XG4gICAgPC9kaXY+XG4gIClcbn1cblxuLy8gTW9jayByZWFsLXRpbWUgY2hhdCBjb21wb25lbnRcbmNvbnN0IE1vY2tDaGF0Q29tcG9uZW50ID0gKHsgXG4gIHNvY2tldCwgXG4gIGlzQ29ubmVjdGVkLCBcbiAgY29ubmVjdGlvblN0YXR1cywgXG4gIHNlbmRNZXNzYWdlIFxufTogYW55KSA9PiB7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gUmVhY3QudXNlU3RhdGU8YW55W10+KFtdKVxuICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSgnJylcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc29ja2V0KSByZXR1cm5cblxuICAgIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwgZGF0YS5wYXlsb2FkXSlcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIG1lc3NhZ2U6JywgZXJyb3IpXG4gICAgICB9XG4gICAgfVxuXG4gICAgc29ja2V0Lm9ubWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2VcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc29ja2V0Lm9ubWVzc2FnZSA9PT0gaGFuZGxlTWVzc2FnZSkge1xuICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSwgW3NvY2tldF0pXG5cbiAgY29uc3QgaGFuZGxlU2VuZE1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgaWYgKGlucHV0VmFsdWUudHJpbSgpICYmIGlzQ29ubmVjdGVkKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiAnbWVzc2FnZScsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICAgIGNvbnRlbnQ6IGlucHV0VmFsdWUsXG4gICAgICAgICAgYXV0aG9yOiAndGVzdHVzZXInLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICBzZXRJbnB1dFZhbHVlKCcnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBkYXRhLXRlc3RpZD1cImNoYXQtY29tcG9uZW50XCI+XG4gICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwiY29ubmVjdGlvbi1zdGF0dXNcIj5cbiAgICAgICAgU3RhdHVzOiB7Y29ubmVjdGlvblN0YXR1c31cbiAgICAgIDwvZGl2PlxuICAgICAgXG4gICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwibWVzc2FnZXMtY29udGFpbmVyXCI+XG4gICAgICAgIHttZXNzYWdlcy5tYXAobXNnID0+IChcbiAgICAgICAgICA8ZGl2IGtleT17bXNnLmlkfSBkYXRhLXRlc3RpZD17YG1lc3NhZ2UtJHttc2cuaWR9YH0+XG4gICAgICAgICAgICA8c3Ryb25nPnttc2cuYXV0aG9yfTo8L3N0cm9uZz4ge21zZy5jb250ZW50fVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwibWVzc2FnZS1pbnB1dC1jb250YWluZXJcIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgZGF0YS10ZXN0aWQ9XCJtZXNzYWdlLWlucHV0XCJcbiAgICAgICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldElucHV0VmFsdWUoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgIG9uS2V5UHJlc3M9eyhlKSA9PiBlLmtleSA9PT0gJ0VudGVyJyAmJiBoYW5kbGVTZW5kTWVzc2FnZSgpfVxuICAgICAgICAgIGRpc2FibGVkPXshaXNDb25uZWN0ZWR9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e2lzQ29ubmVjdGVkID8gJ1R5cGUgYSBtZXNzYWdlLi4uJyA6ICdDb25uZWN0aW5nLi4uJ31cbiAgICAgICAgLz5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGRhdGEtdGVzdGlkPVwic2VuZC1idXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVNlbmRNZXNzYWdlfVxuICAgICAgICAgIGRpc2FibGVkPXshaXNDb25uZWN0ZWQgfHwgIWlucHV0VmFsdWUudHJpbSgpfVxuICAgICAgICA+XG4gICAgICAgICAgU2VuZFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbi8vIE1vY2sgbGl2ZSB1cGRhdGVzIGNvbXBvbmVudFxuY29uc3QgTW9ja0xpdmVVcGRhdGVzQ29tcG9uZW50ID0gKHsgc29ja2V0LCBpc0Nvbm5lY3RlZCB9OiBhbnkpID0+IHtcbiAgY29uc3QgW3Bvc3RzLCBzZXRQb3N0c10gPSBSZWFjdC51c2VTdGF0ZTxhbnlbXT4oW10pXG4gIGNvbnN0IFtub3RpZmljYXRpb25zLCBzZXROb3RpZmljYXRpb25zXSA9IFJlYWN0LnVzZVN0YXRlPGFueVtdPihbXSlcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc29ja2V0KSByZXR1cm5cblxuICAgIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGRhdGFcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IGV2ZW50LmRhdGFcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICduZXdfcG9zdCc6XG4gICAgICAgICAgICBzZXRQb3N0cyhwcmV2ID0+IFtkYXRhLnBheWxvYWQsIC4uLnByZXZdKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdwb3N0X3VwZGF0ZWQnOlxuICAgICAgICAgICAgc2V0UG9zdHMocHJldiA9PiBwcmV2Lm1hcChwb3N0ID0+IFxuICAgICAgICAgICAgICBwb3N0LmlkID09PSBkYXRhLnBheWxvYWQuaWQgPyBkYXRhLnBheWxvYWQgOiBwb3N0XG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdub3RpZmljYXRpb24nOlxuICAgICAgICAgICAgc2V0Tm90aWZpY2F0aW9ucyhwcmV2ID0+IFtkYXRhLnBheWxvYWQsIC4uLnByZXZdKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIGxpdmUgdXBkYXRlOicsIGVycm9yKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHNvY2tldC5vbm1lc3NhZ2UgPT09IGhhbmRsZU1lc3NhZ2UpIHtcbiAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzb2NrZXRdKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBkYXRhLXRlc3RpZD1cImxpdmUtdXBkYXRlc1wiPlxuICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImxpdmUtcG9zdHNcIj5cbiAgICAgICAge3Bvc3RzLm1hcChwb3N0ID0+IChcbiAgICAgICAgICA8ZGl2IGtleT17cG9zdC5pZH0gZGF0YS10ZXN0aWQ9e2BsaXZlLXBvc3QtJHtwb3N0LmlkfWB9PlxuICAgICAgICAgICAge3Bvc3QudGl0bGV9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJsaXZlLW5vdGlmaWNhdGlvbnNcIj5cbiAgICAgICAge25vdGlmaWNhdGlvbnMubWFwKG5vdGlmaWNhdGlvbiA9PiAoXG4gICAgICAgICAgPGRpdiBrZXk9e25vdGlmaWNhdGlvbi5pZH0gZGF0YS10ZXN0aWQ9e2Bub3RpZmljYXRpb24tJHtub3RpZmljYXRpb24uaWR9YH0+XG4gICAgICAgICAgICB7bm90aWZpY2F0aW9uLm1lc3NhZ2V9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZGVzY3JpYmUoJ1dlYlNvY2tldCBJbnRlZ3JhdGlvbiBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgICBNb2NrV2ViU29ja2V0SW5zdGFuY2VzLmxlbmd0aCA9IDBcbiAgfSlcblxuICBkZXNjcmliZSgnQ29ubmVjdGlvbiBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIGl0KCdlc3RhYmxpc2hlcyBXZWJTb2NrZXQgY29ubmVjdGlvbiBvbiBtb3VudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPE1vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwidGVzdC1jb21wb25lbnRcIiAvPlxuICAgICAgICA8L01vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgIClcblxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnd2Vic29ja2V0LXByb3ZpZGVyJykpLnRvQmVJblRoZURvY3VtZW50KClcblxuICAgICAgLy8gV2FpdCBmb3IgY29ubmVjdGlvbiB0byBlc3RhYmxpc2hcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAvLyBDb25uZWN0aW9uIHNob3VsZCBiZSBlc3RhYmxpc2hlZCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIGV4cGVjdChNb2NrV2ViU29ja2V0Q29uc3RydWN0b3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd3czovL2xvY2FsaG9zdDozMDAxJylcbiAgICAgIH0sIHsgdGltZW91dDogMjAwIH0pXG4gICAgfSlcblxuICAgIGl0KCdzaG93cyBjb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8TW9ja1dlYlNvY2tldFByb3ZpZGVyPlxuICAgICAgICAgIDxNb2NrQ2hhdENvbXBvbmVudCAvPlxuICAgICAgICA8L01vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgIClcblxuICAgICAgLy8gSW5pdGlhbGx5IGNvbm5lY3RpbmdcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2Nvbm5lY3Rpb24tc3RhdHVzJykpLnRvSGF2ZVRleHRDb250ZW50KCdTdGF0dXM6IGNvbm5lY3RpbmcnKVxuXG4gICAgICAvLyBXYWl0IGZvciBjb25uZWN0aW9uIHRvIG9wZW5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdjb25uZWN0aW9uLXN0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnU3RhdHVzOiBjb25uZWN0ZWQnKVxuICAgICAgfSwgeyB0aW1lb3V0OiAyMDAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ2hhbmRsZXMgY29ubmVjdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKHsgc29ja2V0IH06IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IFJlYWN0LnVzZVN0YXRlKCcnKVxuXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgc29ja2V0Lm9uZXJyb3IgPSAoKSA9PiBzZXRFcnJvcignQ29ubmVjdGlvbiBmYWlsZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgW3NvY2tldF0pXG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAge2Vycm9yICYmIDxkaXYgZGF0YS10ZXN0aWQ9XCJjb25uZWN0aW9uLWVycm9yXCI+e2Vycm9yfTwvZGl2Pn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxNb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICAgICAgPFRlc3RDb21wb25lbnQgLz5cbiAgICAgICAgPC9Nb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICApXG5cbiAgICAgIC8vIFdhaXQgZm9yIHNvY2tldCB0byBiZSBjcmVhdGVkLCB0aGVuIHNpbXVsYXRlIGVycm9yXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBzY3JlZW4uZ2V0QnlUZXN0SWQoJ3dlYnNvY2tldC1wcm92aWRlcicpXG4gICAgICAgIGV4cGVjdChwcm92aWRlcikudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgICAgfSlcblxuICAgICAgLy8gU2ltdWxhdGUgY29ubmVjdGlvbiBlcnJvclxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gVGhpcyB3b3VsZCBiZSB0cmlnZ2VyZWQgYnkgdGhlIG1vY2sgV2ViU29ja2V0XG4gICAgICAgIGNvbnN0IG1vY2tTb2NrZXQgPSBuZXcgTW9ja1dlYlNvY2tldCgnd3M6Ly9sb2NhbGhvc3Q6MzAwMScpXG4gICAgICAgIG1vY2tTb2NrZXQuc2ltdWxhdGVFcnJvcigpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBpdCgncmVjb25uZWN0cyBvbiBjb25uZWN0aW9uIGxvc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKHsgc29ja2V0LCBjb25uZWN0LCBjb25uZWN0aW9uU3RhdHVzIH06IGFueSkgPT4ge1xuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhdHVzID09PSAnZGlzY29ubmVjdGVkJyAmJiAhc29ja2V0KSB7XG4gICAgICAgICAgICAvLyBBdXRvLXJlY29ubmVjdCBsb2dpY1xuICAgICAgICAgICAgc2V0VGltZW91dChjb25uZWN0LCAxMDAwKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgW2Nvbm5lY3Rpb25TdGF0dXMsIHNvY2tldCwgY29ubmVjdF0pXG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwiY29ubmVjdGlvbi1zdGF0dXNcIj5cbiAgICAgICAgICAgIFN0YXR1czoge2Nvbm5lY3Rpb25TdGF0dXN9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8TW9ja1dlYlNvY2tldFByb3ZpZGVyPlxuICAgICAgICAgIDxUZXN0Q29tcG9uZW50IC8+XG4gICAgICAgIDwvTW9ja1dlYlNvY2tldFByb3ZpZGVyPlxuICAgICAgKVxuXG4gICAgICAvLyBXYWl0IGZvciBpbml0aWFsIGNvbm5lY3Rpb25cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdjb25uZWN0aW9uLXN0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnU3RhdHVzOiBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgLy8gU2ltdWxhdGUgY29ubmVjdGlvbiBsb3NzXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrU29ja2V0ID0gbmV3IE1vY2tXZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjMwMDEnKVxuICAgICAgICBtb2NrU29ja2V0LnNpbXVsYXRlQ2xvc2UoKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdSZWFsLXRpbWUgQ2hhdCcsICgpID0+IHtcbiAgICBpdCgnc2VuZHMgYW5kIHJlY2VpdmVzIGNoYXQgbWVzc2FnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKClcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8TW9ja1dlYlNvY2tldFByb3ZpZGVyPlxuICAgICAgICAgIDxNb2NrQ2hhdENvbXBvbmVudCAvPlxuICAgICAgICA8L01vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgIClcblxuICAgICAgLy8gV2FpdCBmb3IgY29ubmVjdGlvblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2Nvbm5lY3Rpb24tc3RhdHVzJykpLnRvSGF2ZVRleHRDb250ZW50KCdTdGF0dXM6IGNvbm5lY3RlZCcpXG4gICAgICB9KVxuXG4gICAgICAvLyBUeXBlIGFuZCBzZW5kIG1lc3NhZ2VcbiAgICAgIGNvbnN0IGlucHV0ID0gc2NyZWVuLmdldEJ5VGVzdElkKCdtZXNzYWdlLWlucHV0JylcbiAgICAgIGNvbnN0IHNlbmRCdXR0b24gPSBzY3JlZW4uZ2V0QnlUZXN0SWQoJ3NlbmQtYnV0dG9uJylcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0LCAnSGVsbG8sIHdvcmxkIScpXG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKHNlbmRCdXR0b24pXG5cbiAgICAgIC8vIE1lc3NhZ2Ugc2hvdWxkIGJlIHNlbnQgYW5kIGVjaG9lZCBiYWNrXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZXNDb250YWluZXIgPSBzY3JlZW4uZ2V0QnlUZXN0SWQoJ21lc3NhZ2VzLWNvbnRhaW5lcicpXG4gICAgICAgIGV4cGVjdChtZXNzYWdlc0NvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgndGVzdHVzZXI6JykpLnRvQmVJblRoZURvY3VtZW50KClcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0hlbGxvLCB3b3JsZCEnKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgICAgfSlcblxuICAgICAgLy8gSW5wdXQgc2hvdWxkIGJlIGNsZWFyZWRcbiAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlVmFsdWUoJycpXG4gICAgfSlcblxuICAgIGl0KCdkaXNhYmxlcyBpbnB1dCB3aGVuIGRpc2Nvbm5lY3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPE1vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgICAgICA8TW9ja0NoYXRDb21wb25lbnQgLz5cbiAgICAgICAgPC9Nb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICApXG5cbiAgICAgIGNvbnN0IGlucHV0ID0gc2NyZWVuLmdldEJ5VGVzdElkKCdtZXNzYWdlLWlucHV0JylcbiAgICAgIGNvbnN0IHNlbmRCdXR0b24gPSBzY3JlZW4uZ2V0QnlUZXN0SWQoJ3NlbmQtYnV0dG9uJylcblxuICAgICAgLy8gSW5pdGlhbGx5IGRpc2FibGVkIHdoaWxlIGNvbm5lY3RpbmdcbiAgICAgIGV4cGVjdChpbnB1dCkudG9CZURpc2FibGVkKClcbiAgICAgIGV4cGVjdChzZW5kQnV0dG9uKS50b0JlRGlzYWJsZWQoKVxuXG4gICAgICAvLyBXYWl0IGZvciBjb25uZWN0aW9uXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KGlucHV0KS5ub3QudG9CZURpc2FibGVkKClcbiAgICAgICAgZXhwZWN0KHNlbmRCdXR0b24pLnRvQmVEaXNhYmxlZCgpIC8vIFN0aWxsIGRpc2FibGVkIGR1ZSB0byBlbXB0eSBpbnB1dFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ2hhbmRsZXMgbWVzc2FnZSBzZW5kaW5nIHdpdGggRW50ZXIga2V5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdXNlciA9IHVzZXJFdmVudC5zZXR1cCgpXG4gICAgICBcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPE1vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgICAgICA8TW9ja0NoYXRDb21wb25lbnQgLz5cbiAgICAgICAgPC9Nb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICApXG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdjb25uZWN0aW9uLXN0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnU3RhdHVzOiBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgY29uc3QgaW5wdXQgPSBzY3JlZW4uZ2V0QnlUZXN0SWQoJ21lc3NhZ2UtaW5wdXQnKVxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0LCAnVGVzdCBtZXNzYWdle2VudGVyfScpXG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVGVzdCBtZXNzYWdlJykpLnRvQmVJblRoZURvY3VtZW50KClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnTGl2ZSBVcGRhdGVzJywgKCkgPT4ge1xuICAgIGl0KCdyZWNlaXZlcyBhbmQgZGlzcGxheXMgbmV3IHBvc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHRlc3RTb2NrZXQ6IE1vY2tXZWJTb2NrZXQgfCBudWxsID0gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBbc29ja2V0LCBzZXRTb2NrZXRdID0gUmVhY3QudXNlU3RhdGU8TW9ja1dlYlNvY2tldCB8IG51bGw+KG51bGwpXG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHdzID0gbmV3IE1vY2tXZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjMwMDEnKVxuICAgICAgICAgIHRlc3RTb2NrZXQgPSB3c1xuICAgICAgICAgIHNldFNvY2tldCh3cylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGZvciBjb25uZWN0aW9uIHRvIG9wZW4sIHRoZW4gc2ltdWxhdGUgbWVzc2FnZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IE1vY2tXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgICB3cy5zaW11bGF0ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICduZXdfcG9zdCcsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiAnTGl2ZSBQb3N0IFVwZGF0ZScsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiAnVGVzdCBjb250ZW50JyxcbiAgICAgICAgICAgICAgICAgIGF1dGhvcjogJ3Rlc3R1c2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCA1MClcbiAgICAgICAgfSwgW10pXG5cbiAgICAgICAgcmV0dXJuIDxNb2NrTGl2ZVVwZGF0ZXNDb21wb25lbnQgc29ja2V0PXtzb2NrZXR9IGlzQ29ubmVjdGVkPXt0cnVlfSAvPlxuICAgICAgfVxuXG4gICAgICByZW5kZXIoPFRlc3RDb21wb25lbnQgLz4pXG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnTGl2ZSBQb3N0IFVwZGF0ZScpKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICB9LCB7IHRpbWVvdXQ6IDIwMDAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ3JlY2VpdmVzIGFuZCBkaXNwbGF5cyBub3RpZmljYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHRlc3RTb2NrZXQ6IE1vY2tXZWJTb2NrZXQgfCBudWxsID0gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBbc29ja2V0LCBzZXRTb2NrZXRdID0gUmVhY3QudXNlU3RhdGU8TW9ja1dlYlNvY2tldCB8IG51bGw+KG51bGwpXG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHdzID0gbmV3IE1vY2tXZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjMwMDEnKVxuICAgICAgICAgIHRlc3RTb2NrZXQgPSB3c1xuICAgICAgICAgIHNldFNvY2tldCh3cylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGZvciBjb25uZWN0aW9uIHRvIG9wZW4sIHRoZW4gc2ltdWxhdGUgbWVzc2FnZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IE1vY2tXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgICB3cy5zaW11bGF0ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdub3RpZmljYXRpb24nLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAnMScsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTmV3IG5vdGlmaWNhdGlvbiByZWNlaXZlZCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTApXG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIHJldHVybiA8TW9ja0xpdmVVcGRhdGVzQ29tcG9uZW50IHNvY2tldD17c29ja2V0fSBpc0Nvbm5lY3RlZD17dHJ1ZX0gLz5cbiAgICAgIH1cblxuICAgICAgcmVuZGVyKDxUZXN0Q29tcG9uZW50IC8+KVxuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ05ldyBub3RpZmljYXRpb24gcmVjZWl2ZWQnKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgICAgfSwgeyB0aW1lb3V0OiAyMDAwIH0pXG4gICAgfSlcblxuICAgIGl0KCd1cGRhdGVzIGV4aXN0aW5nIHBvc3RzIHdoZW4gbW9kaWZpZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgdGVzdFNvY2tldDogTW9ja1dlYlNvY2tldCB8IG51bGwgPSBudWxsXG4gICAgICBcbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IFtzb2NrZXQsIHNldFNvY2tldF0gPSBSZWFjdC51c2VTdGF0ZTxNb2NrV2ViU29ja2V0IHwgbnVsbD4obnVsbClcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3MgPSBuZXcgTW9ja1dlYlNvY2tldCgnd3M6Ly9sb2NhbGhvc3Q6MzAwMScpXG4gICAgICAgICAgdGVzdFNvY2tldCA9IHdzXG4gICAgICAgICAgc2V0U29ja2V0KHdzKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdhaXQgZm9yIGNvbm5lY3Rpb24gdG8gb3BlbiwgdGhlbiBzaW11bGF0ZSBtZXNzYWdlc1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IE1vY2tXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgICAvLyBGaXJzdCwgYWRkIGEgcG9zdFxuICAgICAgICAgICAgICB3cy5zaW11bGF0ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICduZXdfcG9zdCcsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiAnT3JpZ2luYWwgVGl0bGUnLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogJ09yaWdpbmFsIGNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgYXV0aG9yOiAndGVzdHVzZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVGhlbiB1cGRhdGUgaXRcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgd3Muc2ltdWxhdGVNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3N0X3VwZGF0ZWQnLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJzEnLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1VwZGF0ZWQgVGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnVXBkYXRlZCBjb250ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgYXV0aG9yOiAndGVzdHVzZXInXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSwgMTApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTApXG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIHJldHVybiA8TW9ja0xpdmVVcGRhdGVzQ29tcG9uZW50IHNvY2tldD17c29ja2V0fSBpc0Nvbm5lY3RlZD17dHJ1ZX0gLz5cbiAgICAgIH1cblxuICAgICAgcmVuZGVyKDxUZXN0Q29tcG9uZW50IC8+KVxuXG4gICAgICAvLyBXYWl0IGZvciBvcmlnaW5hbCBwb3N0XG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ09yaWdpbmFsIFRpdGxlJykpLnRvQmVJblRoZURvY3VtZW50KClcbiAgICAgIH0sIHsgdGltZW91dDogMjAwMCB9KVxuXG4gICAgICAvLyBXYWl0IGZvciB1cGRhdGVcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVXBkYXRlZCBUaXRsZScpKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ09yaWdpbmFsIFRpdGxlJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICB9LCB7IHRpbWVvdXQ6IDEwMDAgfSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnaGFuZGxlcyBtYWxmb3JtZWQgV2ViU29ja2V0IG1lc3NhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKClcbiAgICAgIFxuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IFJlYWN0LnVzZVN0YXRlPE1vY2tXZWJTb2NrZXQgfCBudWxsPihudWxsKVxuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCB3cyA9IG5ldyBNb2NrV2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDozMDAxJylcbiAgICAgICAgICBzZXRTb2NrZXQod3MpXG4gICAgICAgICAgXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gTW9ja1dlYlNvY2tldC5PUEVOICYmIHdzLm9ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAvLyBTZW5kIG1hbGZvcm1lZCBKU09OXG4gICAgICAgICAgICAgIHdzLm9ubWVzc2FnZShuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywgeyBcbiAgICAgICAgICAgICAgICBkYXRhOiAnaW52YWxpZCBqc29uJyBcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTApXG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIHJldHVybiA8TW9ja0xpdmVVcGRhdGVzQ29tcG9uZW50IHNvY2tldD17c29ja2V0fSBpc0Nvbm5lY3RlZD17dHJ1ZX0gLz5cbiAgICAgIH1cblxuICAgICAgcmVuZGVyKDxUZXN0Q29tcG9uZW50IC8+KVxuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICdGYWlsZWQgdG8gcGFyc2UgbGl2ZSB1cGRhdGU6JyxcbiAgICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgICApXG4gICAgICB9LCB7IHRpbWVvdXQ6IDEwMDAgfSlcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpXG4gICAgfSlcblxuICAgIGl0KCdncmFjZWZ1bGx5IGhhbmRsZXMgdW5rbm93biBtZXNzYWdlIHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IFJlYWN0LnVzZVN0YXRlPE1vY2tXZWJTb2NrZXQgfCBudWxsPihudWxsKVxuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCB3cyA9IG5ldyBNb2NrV2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDozMDAxJylcbiAgICAgICAgICBzZXRTb2NrZXQod3MpXG4gICAgICAgICAgXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gTW9ja1dlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICAgIHdzLnNpbXVsYXRlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Vua25vd25fdHlwZScsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogeyBkYXRhOiAndGVzdCcgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDUwKVxuICAgICAgICB9LCBbXSlcblxuICAgICAgICByZXR1cm4gPE1vY2tMaXZlVXBkYXRlc0NvbXBvbmVudCBzb2NrZXQ9e3NvY2tldH0gaXNDb25uZWN0ZWQ9e3RydWV9IC8+XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcig8VGVzdENvbXBvbmVudCAvPilcblxuICAgICAgLy8gU2hvdWxkIG5vdCBjcmFzaCBvciBzaG93IGFueSBlcnJvclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2xpdmUtdXBkYXRlcycpKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIGl0KCdoYW5kbGVzIGhpZ2gtZnJlcXVlbmN5IG1lc3NhZ2VzIHdpdGhvdXQgcGVyZm9ybWFuY2UgaXNzdWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IFJlYWN0LnVzZVN0YXRlPE1vY2tXZWJTb2NrZXQgfCBudWxsPihudWxsKVxuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCB3cyA9IG5ldyBNb2NrV2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDozMDAxJylcbiAgICAgICAgICBzZXRTb2NrZXQod3MpXG4gICAgICAgICAgXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gTW9ja1dlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICAgIC8vIFNlbmQgbWFueSBtZXNzYWdlcyByYXBpZGx5XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgIHdzLnNpbXVsYXRlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnbm90aWZpY2F0aW9uJyxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYE1lc3NhZ2UgJHtpfWAsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbmZvJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCA1MClcbiAgICAgICAgfSwgW10pXG5cbiAgICAgICAgcmV0dXJuIDxNb2NrTGl2ZVVwZGF0ZXNDb21wb25lbnQgc29ja2V0PXtzb2NrZXR9IGlzQ29ubmVjdGVkPXt0cnVlfSAvPlxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgXG4gICAgICByZW5kZXIoPFRlc3RDb21wb25lbnQgLz4pXG5cbiAgICAgIC8vIFdhaXQgZm9yIG1lc3NhZ2VzIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QWxsQnlUZXN0SWQoL25vdGlmaWNhdGlvbi0vKS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMTApXG4gICAgICB9LCB7IHRpbWVvdXQ6IDMwMDAgfSlcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWVcblxuICAgICAgLy8gU2hvdWxkIHByb2Nlc3MgbWVzc2FnZXMgcmVhc29uYWJseSBxdWlja2x5XG4gICAgICBleHBlY3QocHJvY2Vzc2luZ1RpbWUpLnRvQmVMZXNzVGhhbigzMDAwKVxuICAgIH0pXG4gIH0pXG59KVxuIl0sIm5hbWVzIjpbIk1vY2tXZWJTb2NrZXRJbnN0YW5jZXMiLCJNb2NrV2ViU29ja2V0IiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TSU5HIiwiQ0xPU0VEIiwidXJsIiwicmVhZHlTdGF0ZSIsIm9ub3BlbiIsIm9uY2xvc2UiLCJvbm1lc3NhZ2UiLCJvbmVycm9yIiwicHVzaCIsInNldFRpbWVvdXQiLCJFdmVudCIsInNlbmQiLCJkYXRhIiwiRXJyb3IiLCJNZXNzYWdlRXZlbnQiLCJjbG9zZSIsIkNsb3NlRXZlbnQiLCJzaW11bGF0ZU1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5Iiwic2ltdWxhdGVFcnJvciIsInNpbXVsYXRlQ2xvc2UiLCJNb2NrV2ViU29ja2V0Q29uc3RydWN0b3IiLCJqZXN0IiwiZm4iLCJtb2NrSW1wbGVtZW50YXRpb24iLCJnbG9iYWwiLCJXZWJTb2NrZXQiLCJNb2NrV2ViU29ja2V0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInNvY2tldCIsInNldFNvY2tldCIsIlJlYWN0IiwidXNlU3RhdGUiLCJpc0Nvbm5lY3RlZCIsInNldElzQ29ubmVjdGVkIiwiY29ubmVjdGlvblN0YXR1cyIsInNldENvbm5lY3Rpb25TdGF0dXMiLCJjb25uZWN0IiwidXNlQ2FsbGJhY2siLCJ3cyIsInVzZUVmZmVjdCIsImRpc2Nvbm5lY3QiLCJzZW5kTWVzc2FnZSIsIm1lc3NhZ2UiLCJjb250ZXh0VmFsdWUiLCJkaXYiLCJkYXRhLXRlc3RpZCIsIkNoaWxkcmVuIiwibWFwIiwiY2hpbGQiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsIk1vY2tDaGF0Q29tcG9uZW50IiwibWVzc2FnZXMiLCJzZXRNZXNzYWdlcyIsImlucHV0VmFsdWUiLCJzZXRJbnB1dFZhbHVlIiwiaGFuZGxlTWVzc2FnZSIsImV2ZW50IiwicGFyc2UiLCJ0eXBlIiwicHJldiIsInBheWxvYWQiLCJlcnJvciIsImNvbnNvbGUiLCJoYW5kbGVTZW5kTWVzc2FnZSIsInRyaW0iLCJpZCIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsImNvbnRlbnQiLCJhdXRob3IiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsIm1zZyIsInN0cm9uZyIsImlucHV0IiwidmFsdWUiLCJvbkNoYW5nZSIsImUiLCJ0YXJnZXQiLCJvbktleVByZXNzIiwia2V5IiwiZGlzYWJsZWQiLCJwbGFjZWhvbGRlciIsImJ1dHRvbiIsIm9uQ2xpY2siLCJNb2NrTGl2ZVVwZGF0ZXNDb21wb25lbnQiLCJwb3N0cyIsInNldFBvc3RzIiwibm90aWZpY2F0aW9ucyIsInNldE5vdGlmaWNhdGlvbnMiLCJwb3N0IiwidGl0bGUiLCJub3RpZmljYXRpb24iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibGVuZ3RoIiwiaXQiLCJyZW5kZXIiLCJleHBlY3QiLCJzY3JlZW4iLCJnZXRCeVRlc3RJZCIsInRvQmVJblRoZURvY3VtZW50Iiwid2FpdEZvciIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwidGltZW91dCIsInRvSGF2ZVRleHRDb250ZW50IiwiVGVzdENvbXBvbmVudCIsInNldEVycm9yIiwicHJvdmlkZXIiLCJhY3QiLCJtb2NrU29ja2V0IiwidXNlciIsInVzZXJFdmVudCIsInNldHVwIiwic2VuZEJ1dHRvbiIsImNsaWNrIiwibWVzc2FnZXNDb250YWluZXIiLCJ0b0JlR3JlYXRlclRoYW4iLCJnZXRCeVRleHQiLCJ0b0hhdmVWYWx1ZSIsInRvQmVEaXNhYmxlZCIsIm5vdCIsInRlc3RTb2NrZXQiLCJxdWVyeUJ5VGV4dCIsImNvbnNvbGVTcHkiLCJzcHlPbiIsImFueSIsIm1vY2tSZXN0b3JlIiwiaSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwiZ2V0QWxsQnlUZXN0SWQiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwiZW5kVGltZSIsInByb2Nlc3NpbmdUaW1lIiwidG9CZUxlc3NUaGFuIl0sIm1hcHBpbmdzIjoiOzs7Ozs4REFBa0I7d0JBQzJCO2tFQUN2Qjs7Ozs7O0FBRXRCLGlCQUFpQjtBQUNqQixNQUFNQSx5QkFBMEMsRUFBRTtBQUVsRCxNQUFNQzs7YUFDR0MsYUFBYTs7O2FBQ2JDLE9BQU87OzthQUNQQyxVQUFVOzs7YUFDVkMsU0FBUzs7SUFTaEIsWUFBWUMsR0FBVyxDQUFFO2FBTnpCQyxhQUFxQk4sY0FBY0MsVUFBVTthQUM3Q00sU0FBMEM7YUFDMUNDLFVBQWdEO2FBQ2hEQyxZQUFvRDthQUNwREMsVUFBMkM7UUFHekMsSUFBSSxDQUFDTCxHQUFHLEdBQUdBO1FBQ1hOLHVCQUF1QlksSUFBSSxDQUFDLElBQUk7UUFDaEMsOEJBQThCO1FBQzlCQyxXQUFXO1lBQ1QsSUFBSSxDQUFDTixVQUFVLEdBQUdOLGNBQWNFLElBQUk7WUFDcEMsSUFBSSxJQUFJLENBQUNLLE1BQU0sRUFBRTtnQkFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQyxJQUFJTSxNQUFNO1lBQ3hCO1FBQ0YsR0FBRztJQUNMO0lBRUFDLEtBQUtDLElBQVksRUFBRTtRQUNqQixJQUFJLElBQUksQ0FBQ1QsVUFBVSxLQUFLTixjQUFjRSxJQUFJLEVBQUU7WUFDMUMsTUFBTSxJQUFJYyxNQUFNO1FBQ2xCO1FBQ0Esd0JBQXdCO1FBQ3hCSixXQUFXO1lBQ1QsSUFBSSxJQUFJLENBQUNILFNBQVMsRUFBRTtnQkFDbEIsSUFBSSxDQUFDQSxTQUFTLENBQUMsSUFBSVEsYUFBYSxXQUFXO29CQUFFRjtnQkFBSztZQUNwRDtRQUNGLEdBQUc7SUFDTDtJQUVBRyxRQUFRO1FBQ04sSUFBSSxDQUFDWixVQUFVLEdBQUdOLGNBQWNJLE1BQU07UUFDdEMsSUFBSSxJQUFJLENBQUNJLE9BQU8sRUFBRTtZQUNoQixJQUFJLENBQUNBLE9BQU8sQ0FBQyxJQUFJVyxXQUFXO1FBQzlCO0lBQ0Y7SUFFQSxlQUFlO0lB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