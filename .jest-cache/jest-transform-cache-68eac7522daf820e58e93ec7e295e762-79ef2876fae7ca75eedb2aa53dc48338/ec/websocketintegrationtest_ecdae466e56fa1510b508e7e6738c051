0efa249f1e213e7ff9b5e8e020a624db
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _react1 = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock WebSocket
const MockWebSocketInstances = [];
class MockWebSocket {
    static{
        this.CONNECTING = 0;
    }
    static{
        this.OPEN = 1;
    }
    static{
        this.CLOSING = 2;
    }
    static{
        this.CLOSED = 3;
    }
    constructor(url){
        this.readyState = MockWebSocket.CONNECTING;
        this.onopen = null;
        this.onclose = null;
        this.onmessage = null;
        this.onerror = null;
        this.url = url;
        MockWebSocketInstances.push(this);
        // Simulate connection opening
        setTimeout(()=>{
            this.readyState = MockWebSocket.OPEN;
            if (this.onopen) {
                this.onopen(new Event('open'));
            }
        }, 10);
    }
    send(data) {
        if (this.readyState !== MockWebSocket.OPEN) {
            throw new Error('WebSocket is not open');
        }
        // Echo back for testing
        setTimeout(()=>{
            if (this.onmessage) {
                this.onmessage(new MessageEvent('message', {
                    data
                }));
            }
        }, 50);
    }
    close() {
        this.readyState = MockWebSocket.CLOSED;
        if (this.onclose) {
            this.onclose(new CloseEvent('close'));
        }
    }
    // Test helpers
    simulateMessage(data) {
        if (this.onmessage && this.readyState === MockWebSocket.OPEN) {
            // Trigger immediately for tests
            this.onmessage(new MessageEvent('message', {
                data: typeof data === 'string' ? data : JSON.stringify(data)
            }));
        }
    }
    simulateError() {
        if (this.onerror) {
            this.onerror(new Event('error'));
        }
    }
    simulateClose() {
        this.readyState = MockWebSocket.CLOSED;
        if (this.onclose) {
            this.onclose(new CloseEvent('close'));
        }
    }
}
// Create a Jest mock for WebSocket constructor
const MockWebSocketConstructor = jest.fn().mockImplementation((url)=>{
    return new MockWebSocket(url);
});
// Replace global WebSocket with mock
global.WebSocket = MockWebSocketConstructor;
// Mock WebSocket context and provider
const MockWebSocketProvider = ({ children })=>{
    const [socket, setSocket] = _react.default.useState(null);
    const [isConnected, setIsConnected] = _react.default.useState(false);
    const [connectionStatus, setConnectionStatus] = _react.default.useState('disconnected');
    const connect = _react.default.useCallback(()=>{
        if (socket) return;
        const ws = new global.WebSocket('ws://localhost:3001');
        ws.onopen = ()=>{
            setIsConnected(true);
            setConnectionStatus('connected');
        };
        ws.onclose = ()=>{
            setIsConnected(false);
            setConnectionStatus('disconnected');
            setSocket(null);
        };
        ws.onerror = ()=>{
            setConnectionStatus('disconnected');
            setIsConnected(false);
        };
        setSocket(ws);
        setConnectionStatus('connecting');
        // Simulate connection opening after a brief delay
        setTimeout(()=>{
            if (ws.onopen) ws.onopen(new Event('open'));
        }, 10);
    }, [
        socket
    ]);
    // Auto-connect on mount
    _react.default.useEffect(()=>{
        connect();
    }, [
        connect
    ]);
    const disconnect = _react.default.useCallback(()=>{
        if (socket) {
            socket.close();
        }
    }, [
        socket
    ]);
    const sendMessage = _react.default.useCallback((message)=>{
        if (socket && isConnected) {
            socket.send(JSON.stringify(message));
        }
    }, [
        socket,
        isConnected
    ]);
    _react.default.useEffect(()=>{
        connect();
        return ()=>disconnect();
    }, [
        connect,
        disconnect
    ]);
    const contextValue = {
        socket,
        isConnected,
        connectionStatus,
        connect,
        disconnect,
        sendMessage
    };
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        "data-testid": "websocket-provider",
        children: _react.default.Children.map(children, (child)=>/*#__PURE__*/ _react.default.isValidElement(child) ? /*#__PURE__*/ _react.default.cloneElement(child, {
                ...contextValue
            }) : child)
    });
};
// Mock real-time chat component
const MockChatComponent = ({ socket, isConnected, connectionStatus, sendMessage })=>{
    const [messages, setMessages] = _react.default.useState([]);
    const [inputValue, setInputValue] = _react.default.useState('');
    _react.default.useEffect(()=>{
        if (!socket) return;
        const handleMessage = (event)=>{
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'message') {
                    setMessages((prev)=>[
                            ...prev,
                            data.payload
                        ]);
                }
            } catch (error) {
                console.error('Failed to parse message:', error);
            }
        };
        socket.onmessage = handleMessage;
        return ()=>{
            if (socket.onmessage === handleMessage) {
                socket.onmessage = null;
            }
        };
    }, [
        socket
    ]);
    const handleSendMessage = ()=>{
        if (inputValue.trim() && isConnected) {
            const message = {
                type: 'message',
                payload: {
                    id: Date.now().toString(),
                    content: inputValue,
                    author: 'testuser',
                    timestamp: new Date().toISOString()
                }
            };
            sendMessage(message);
            setInputValue('');
        }
    };
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
        "data-testid": "chat-component",
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                "data-testid": "connection-status",
                children: [
                    "Status: ",
                    connectionStatus
                ]
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "messages-container",
                children: messages.map((msg)=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                        "data-testid": `message-${msg.id}`,
                        children: [
                            /*#__PURE__*/ (0, _jsxruntime.jsxs)("strong", {
                                children: [
                                    msg.author,
                                    ":"
                                ]
                            }),
                            " ",
                            msg.content
                        ]
                    }, msg.id))
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                "data-testid": "message-input-container",
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("input", {
                        "data-testid": "message-input",
                        value: inputValue,
                        onChange: (e)=>setInputValue(e.target.value),
                        onKeyPress: (e)=>e.key === 'Enter' && handleSendMessage(),
                        disabled: !isConnected,
                        placeholder: isConnected ? 'Type a message...' : 'Connecting...'
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                        "data-testid": "send-button",
                        onClick: handleSendMessage,
                        disabled: !isConnected || !inputValue.trim(),
                        children: "Send"
                    })
                ]
            })
        ]
    });
};
// Mock live updates component
const MockLiveUpdatesComponent = ({ socket, isConnected })=>{
    const [posts, setPosts] = _react.default.useState([]);
    const [notifications, setNotifications] = _react.default.useState([]);
    _react.default.useEffect(()=>{
        if (!socket) return;
        const handleMessage = (event)=>{
            try {
                let data;
                if (typeof event.data === 'string') {
                    data = JSON.parse(event.data);
                } else {
                    data = event.data;
                }
                switch(data.type){
                    case 'new_post':
                        setPosts((prev)=>[
                                data.payload,
                                ...prev
                            ]);
                        break;
                    case 'post_updated':
                        setPosts((prev)=>prev.map((post)=>post.id === data.payload.id ? data.payload : post));
                        break;
                    case 'notification':
                        setNotifications((prev)=>[
                                data.payload,
                                ...prev
                            ]);
                        break;
                }
            } catch (error) {
                console.error('Failed to parse live update:', error);
            }
        };
        socket.onmessage = handleMessage;
        return ()=>{
            if (socket.onmessage === handleMessage) {
                socket.onmessage = null;
            }
        };
    }, [
        socket
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
        "data-testid": "live-updates",
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "live-posts",
                children: posts.map((post)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": `live-post-${post.id}`,
                        children: post.title
                    }, post.id))
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "live-notifications",
                children: notifications.map((notification)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": `notification-${notification.id}`,
                        children: notification.message
                    }, notification.id))
            })
        ]
    });
};
describe('WebSocket Integration Tests', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        MockWebSocketInstances.length = 0;
    });
    describe('Connection Management', ()=>{
        it('establishes WebSocket connection on mount', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "test-component"
                })
            }));
            expect(_react1.screen.getByTestId('websocket-provider')).toBeInTheDocument();
            // Wait for connection to establish
            await (0, _react1.waitFor)(()=>{
                // Connection should be established automatically
                expect(MockWebSocketConstructor).toHaveBeenCalledWith('ws://localhost:3001');
            }, {
                timeout: 200
            });
        });
        it('shows connection status changes', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MockChatComponent, {})
            }));
            // Initially connecting
            expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connecting');
            // Wait for connection to open
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connected');
            }, {
                timeout: 200
            });
        });
        it('handles connection errors', async ()=>{
            const TestComponent = ({ socket })=>{
                const [error, setError] = _react.default.useState('');
                _react.default.useEffect(()=>{
                    if (socket) {
                        socket.onerror = ()=>setError('Connection failed');
                    }
                }, [
                    socket
                ]);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    children: error && /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": "connection-error",
                        children: error
                    })
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {})
            }));
            // Wait for socket to be created, then simulate error
            await (0, _react1.waitFor)(()=>{
                const provider = _react1.screen.getByTestId('websocket-provider');
                expect(provider).toBeInTheDocument();
            });
            // Simulate connection error
            await (0, _react.act)(async ()=>{
                // This would be triggered by the mock WebSocket
                const mockSocket = new MockWebSocket('ws://localhost:3001');
                mockSocket.simulateError();
            });
        });
        it('reconnects on connection loss', async ()=>{
            const TestComponent = ({ socket, connect, connectionStatus })=>{
                _react.default.useEffect(()=>{
                    if (connectionStatus === 'disconnected' && !socket) {
                        // Auto-reconnect logic
                        setTimeout(connect, 1000);
                    }
                }, [
                    connectionStatus,
                    socket,
                    connect
                ]);
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    "data-testid": "connection-status",
                    children: [
                        "Status: ",
                        connectionStatus
                    ]
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {})
            }));
            // Wait for initial connection
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connected');
            });
            // Simulate connection loss
            await (0, _react.act)(async ()=>{
                const mockSocket = new MockWebSocket('ws://localhost:3001');
                mockSocket.simulateClose();
            });
        });
    });
    describe('Real-time Chat', ()=>{
        it('sends and receives chat messages', async ()=>{
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MockChatComponent, {})
            }));
            // Wait for connection
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connected');
            });
            // Type and send message
            const input = _react1.screen.getByTestId('message-input');
            const sendButton = _react1.screen.getByTestId('send-button');
            await user.type(input, 'Hello, world!');
            await user.click(sendButton);
            // Message should be sent and echoed back
            await (0, _react1.waitFor)(()=>{
                const messagesContainer = _react1.screen.getByTestId('messages-container');
                expect(messagesContainer.children.length).toBeGreaterThan(0);
                expect(_react1.screen.getByText('testuser:')).toBeInTheDocument();
                expect(_react1.screen.getByText('Hello, world!')).toBeInTheDocument();
            });
            // Input should be cleared
            expect(input).toHaveValue('');
        });
        it('disables input when disconnected', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MockChatComponent, {})
            }));
            const input = _react1.screen.getByTestId('message-input');
            const sendButton = _react1.screen.getByTestId('send-button');
            // Initially disabled while connecting
            expect(input).toBeDisabled();
            expect(sendButton).toBeDisabled();
            // Wait for connection
            await (0, _react1.waitFor)(()=>{
                expect(input).not.toBeDisabled();
                expect(sendButton).toBeDisabled(); // Still disabled due to empty input
            });
        });
        it('handles message sending with Enter key', async ()=>{
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(MockWebSocketProvider, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MockChatComponent, {})
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('connection-status')).toHaveTextContent('Status: connected');
            });
            const input = _react1.screen.getByTestId('message-input');
            await user.type(input, 'Test message{enter}');
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('Test message')).toBeInTheDocument();
            });
        });
    });
    describe('Live Updates', ()=>{
        it('receives and displays new posts', async ()=>{
            let testSocket = null;
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    testSocket = ws;
                    setSocket(ws);
                    // Wait for connection to open, then simulate message
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            ws.simulateMessage({
                                type: 'new_post',
                                payload: {
                                    id: '1',
                                    title: 'Live Post Update',
                                    content: 'Test content',
                                    author: 'testuser'
                                }
                            });
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('Live Post Update')).toBeInTheDocument();
            }, {
                timeout: 2000
            });
        });
        it('receives and displays notifications', async ()=>{
            let testSocket = null;
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    testSocket = ws;
                    setSocket(ws);
                    // Wait for connection to open, then simulate message
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            ws.simulateMessage({
                                type: 'notification',
                                payload: {
                                    id: '1',
                                    message: 'New notification received'
                                }
                            });
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('New notification received')).toBeInTheDocument();
            }, {
                timeout: 2000
            });
        });
        it('updates existing posts when modified', async ()=>{
            let testSocket = null;
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    testSocket = ws;
                    setSocket(ws);
                    // Wait for connection to open, then simulate messages
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            // First, add a post
                            ws.simulateMessage({
                                type: 'new_post',
                                payload: {
                                    id: '1',
                                    title: 'Original Title',
                                    content: 'Original content',
                                    author: 'testuser'
                                }
                            });
                            // Then update it
                            setTimeout(()=>{
                                ws.simulateMessage({
                                    type: 'post_updated',
                                    payload: {
                                        id: '1',
                                        title: 'Updated Title',
                                        content: 'Updated content',
                                        author: 'testuser'
                                    }
                                });
                            }, 10);
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Wait for original post
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('Original Title')).toBeInTheDocument();
            }, {
                timeout: 2000
            });
            // Wait for update
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('Updated Title')).toBeInTheDocument();
                expect(_react1.screen.queryByText('Original Title')).not.toBeInTheDocument();
            }, {
                timeout: 1000
            });
        });
    });
    describe('Error Handling', ()=>{
        it('handles malformed WebSocket messages', async ()=>{
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    setSocket(ws);
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN && ws.onmessage) {
                            // Send malformed JSON
                            ws.onmessage(new MessageEvent('message', {
                                data: 'invalid json'
                            }));
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(consoleSpy).toHaveBeenCalledWith('Failed to parse live update:', expect.any(Error));
            }, {
                timeout: 1000
            });
            consoleSpy.mockRestore();
        });
        it('gracefully handles unknown message types', async ()=>{
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    setSocket(ws);
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            ws.simulateMessage({
                                type: 'unknown_type',
                                payload: {
                                    data: 'test'
                                }
                            });
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Should not crash or show any error
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('live-updates')).toBeInTheDocument();
            });
        });
    });
    describe('Performance', ()=>{
        it('handles high-frequency messages without performance issues', async ()=>{
            const TestComponent = ()=>{
                const [socket, setSocket] = _react.default.useState(null);
                _react.default.useEffect(()=>{
                    const ws = new MockWebSocket('ws://localhost:3001');
                    setSocket(ws);
                    setTimeout(()=>{
                        if (ws.readyState === MockWebSocket.OPEN) {
                            // Send many messages rapidly
                            for(let i = 0; i < 10; i++){
                                ws.simulateMessage({
                                    type: 'notification',
                                    payload: {
                                        id: i.toString(),
                                        message: `Message ${i}`,
                                        type: 'info'
                                    }
                                });
                            }
                        }
                    }, 50);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(MockLiveUpdatesComponent, {
                    socket: socket,
                    isConnected: true
                });
            };
            const startTime = performance.now();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Wait for messages to be processed
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getAllByTestId(/notification-/).length).toBeGreaterThanOrEqual(10);
            }, {
                timeout: 3000
            });
            const endTime = performance.now();
            const processingTime = endTime - startTime;
            // Should process messages reasonably quickly
            expect(processingTime).toBeLessThan(3000);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3Noc3plcC9jb2RlL3RoZXJvYm90b3ZlcmxvcmQtbW9uby90aGVyb2JvdG92ZXJsb3JkLXdlYi9zcmMvX190ZXN0c19fL2ludGVncmF0aW9uL3dlYnNvY2tldC5pbnRlZ3JhdGlvbi50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnXG5pbXBvcnQgeyBhY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB1c2VyRXZlbnQgZnJvbSAnQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50J1xuaW1wb3J0IHsgY3JlYXRlTW9ja1Bvc3QsIGNyZWF0ZU1vY2tVc2VyIH0gZnJvbSAnQC9fX3Rlc3RzX18vdXRpbHMvdGVzdC11dGlscydcblxuLy8gTW9jayBXZWJTb2NrZXRcbmNvbnN0IE1vY2tXZWJTb2NrZXRJbnN0YW5jZXM6IE1vY2tXZWJTb2NrZXRbXSA9IFtdXG5cbmNsYXNzIE1vY2tXZWJTb2NrZXQge1xuICBzdGF0aWMgQ09OTkVDVElORyA9IDBcbiAgc3RhdGljIE9QRU4gPSAxXG4gIHN0YXRpYyBDTE9TSU5HID0gMlxuICBzdGF0aWMgQ0xPU0VEID0gM1xuXG4gIHVybDogc3RyaW5nXG4gIHJlYWR5U3RhdGU6IG51bWJlciA9IE1vY2tXZWJTb2NrZXQuQ09OTkVDVElOR1xuICBvbm9wZW46ICgoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsXG4gIG9uY2xvc2U6ICgoZXZlbnQ6IENsb3NlRXZlbnQpID0+IHZvaWQpIHwgbnVsbCA9IG51bGxcbiAgb25tZXNzYWdlOiAoKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHZvaWQpIHwgbnVsbCA9IG51bGxcbiAgb25lcnJvcjogKChldmVudDogRXZlbnQpID0+IHZvaWQpIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZykge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgTW9ja1dlYlNvY2tldEluc3RhbmNlcy5wdXNoKHRoaXMpXG4gICAgLy8gU2ltdWxhdGUgY29ubmVjdGlvbiBvcGVuaW5nXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBNb2NrV2ViU29ja2V0Lk9QRU5cbiAgICAgIGlmICh0aGlzLm9ub3Blbikge1xuICAgICAgICB0aGlzLm9ub3BlbihuZXcgRXZlbnQoJ29wZW4nKSlcbiAgICAgIH1cbiAgICB9LCAxMClcbiAgfVxuXG4gIHNlbmQoZGF0YTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gTW9ja1dlYlNvY2tldC5PUEVOKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbicpXG4gICAgfVxuICAgIC8vIEVjaG8gYmFjayBmb3IgdGVzdGluZ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMub25tZXNzYWdlKSB7XG4gICAgICAgIHRoaXMub25tZXNzYWdlKG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2UnLCB7IGRhdGEgfSkpXG4gICAgICB9XG4gICAgfSwgNTApXG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBNb2NrV2ViU29ja2V0LkNMT1NFRFxuICAgIGlmICh0aGlzLm9uY2xvc2UpIHtcbiAgICAgIHRoaXMub25jbG9zZShuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKSlcbiAgICB9XG4gIH1cblxuICAvLyBUZXN0IGhlbHBlcnNcbiAgc2ltdWxhdGVNZXNzYWdlKGRhdGE6IGFueSkge1xuICAgIGlmICh0aGlzLm9ubWVzc2FnZSAmJiB0aGlzLnJlYWR5U3RhdGUgPT09IE1vY2tXZWJTb2NrZXQuT1BFTikge1xuICAgICAgLy8gVHJpZ2dlciBpbW1lZGlhdGVseSBmb3IgdGVzdHNcbiAgICAgIHRoaXMub25tZXNzYWdlKG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2UnLCB7IFxuICAgICAgICBkYXRhOiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhIDogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIHNpbXVsYXRlRXJyb3IoKSB7XG4gICAgaWYgKHRoaXMub25lcnJvcikge1xuICAgICAgdGhpcy5vbmVycm9yKG5ldyBFdmVudCgnZXJyb3InKSlcbiAgICB9XG4gIH1cblxuICBzaW11bGF0ZUNsb3NlKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IE1vY2tXZWJTb2NrZXQuQ0xPU0VEXG4gICAgaWYgKHRoaXMub25jbG9zZSkge1xuICAgICAgdGhpcy5vbmNsb3NlKG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpKVxuICAgIH1cbiAgfVxufVxuXG4vLyBDcmVhdGUgYSBKZXN0IG1vY2sgZm9yIFdlYlNvY2tldCBjb25zdHJ1Y3RvclxuY29uc3QgTW9ja1dlYlNvY2tldENvbnN0cnVjdG9yID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigodXJsOiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIG5ldyBNb2NrV2ViU29ja2V0KHVybClcbn0pXG5cbi8vIFJlcGxhY2UgZ2xvYmFsIFdlYlNvY2tldCB3aXRoIG1vY2tcbmdsb2JhbC5XZWJTb2NrZXQgPSBNb2NrV2ViU29ja2V0Q29uc3RydWN0b3IgYXMgYW55XG5cbi8vIE1vY2sgV2ViU29ja2V0IGNvbnRleHQgYW5kIHByb3ZpZGVyXG5jb25zdCBNb2NrV2ViU29ja2V0UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkgPT4ge1xuICBjb25zdCBbc29ja2V0LCBzZXRTb2NrZXRdID0gUmVhY3QudXNlU3RhdGU8TW9ja1dlYlNvY2tldCB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtjb25uZWN0aW9uU3RhdHVzLCBzZXRDb25uZWN0aW9uU3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlPCdjb25uZWN0aW5nJyB8ICdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCc+KCdkaXNjb25uZWN0ZWQnKVxuXG4gIGNvbnN0IGNvbm5lY3QgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHNvY2tldCkgcmV0dXJuXG5cbiAgICBjb25zdCB3cyA9IG5ldyAoZ2xvYmFsLldlYlNvY2tldCBhcyBhbnkpKCd3czovL2xvY2FsaG9zdDozMDAxJylcbiAgICBcbiAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKVxuICAgICAgc2V0Q29ubmVjdGlvblN0YXR1cygnY29ubmVjdGVkJylcbiAgICB9XG5cbiAgICB3cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXG4gICAgICBzZXRDb25uZWN0aW9uU3RhdHVzKCdkaXNjb25uZWN0ZWQnKVxuICAgICAgc2V0U29ja2V0KG51bGwpXG4gICAgfVxuXG4gICAgd3Mub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHNldENvbm5lY3Rpb25TdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpXG4gICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSlcbiAgICB9XG5cbiAgICBzZXRTb2NrZXQod3MpXG4gICAgc2V0Q29ubmVjdGlvblN0YXR1cygnY29ubmVjdGluZycpXG4gICAgXG4gICAgLy8gU2ltdWxhdGUgY29ubmVjdGlvbiBvcGVuaW5nIGFmdGVyIGEgYnJpZWYgZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh3cy5vbm9wZW4pIHdzLm9ub3BlbihuZXcgRXZlbnQoJ29wZW4nKSlcbiAgICB9LCAxMClcbiAgfSwgW3NvY2tldF0pXG5cbiAgLy8gQXV0by1jb25uZWN0IG9uIG1vdW50XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29ubmVjdCgpXG4gIH0sIFtjb25uZWN0XSlcblxuICBjb25zdCBkaXNjb25uZWN0ID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgIHNvY2tldC5jbG9zZSgpXG4gICAgfVxuICB9LCBbc29ja2V0XSlcblxuICBjb25zdCBzZW5kTWVzc2FnZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChtZXNzYWdlOiBhbnkpID0+IHtcbiAgICBpZiAoc29ja2V0ICYmIGlzQ29ubmVjdGVkKSB7XG4gICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSlcbiAgICB9XG4gIH0sIFtzb2NrZXQsIGlzQ29ubmVjdGVkXSlcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbm5lY3QoKVxuICAgIHJldHVybiAoKSA9PiBkaXNjb25uZWN0KClcbiAgfSwgW2Nvbm5lY3QsIGRpc2Nvbm5lY3RdKVxuXG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHtcbiAgICBzb2NrZXQsXG4gICAgaXNDb25uZWN0ZWQsXG4gICAgY29ubmVjdGlvblN0YXR1cyxcbiAgICBjb25uZWN0LFxuICAgIGRpc2Nvbm5lY3QsXG4gICAgc2VuZE1lc3NhZ2VcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBkYXRhLXRlc3RpZD1cIndlYnNvY2tldC1wcm92aWRlclwiPlxuICAgICAge1JlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT4gXG4gICAgICAgIFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSBcbiAgICAgICAgICA/IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgeyAuLi5jb250ZXh0VmFsdWUgfSlcbiAgICAgICAgICA6IGNoaWxkXG4gICAgICApfVxuICAgIDwvZGl2PlxuICApXG59XG5cbi8vIE1vY2sgcmVhbC10aW1lIGNoYXQgY29tcG9uZW50XG5jb25zdCBNb2NrQ2hhdENvbXBvbmVudCA9ICh7IFxuICBzb2NrZXQsIFxuICBpc0Nvbm5lY3RlZCwgXG4gIGNvbm5lY3Rpb25TdGF0dXMsIFxuICBzZW5kTWVzc2FnZSBcbn06IGFueSkgPT4ge1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IFJlYWN0LnVzZVN0YXRlPGFueVtdPihbXSlcbiAgY29uc3QgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoJycpXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNvY2tldCkgcmV0dXJuXG5cbiAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIGRhdGEucGF5bG9hZF0pXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBtZXNzYWdlOicsIGVycm9yKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHNvY2tldC5vbm1lc3NhZ2UgPT09IGhhbmRsZU1lc3NhZ2UpIHtcbiAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzb2NrZXRdKVxuXG4gIGNvbnN0IGhhbmRsZVNlbmRNZXNzYWdlID0gKCkgPT4ge1xuICAgIGlmIChpbnB1dFZhbHVlLnRyaW0oKSAmJiBpc0Nvbm5lY3RlZCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogJ21lc3NhZ2UnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICBjb250ZW50OiBpbnB1dFZhbHVlLFxuICAgICAgICAgIGF1dGhvcjogJ3Rlc3R1c2VyJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZW5kTWVzc2FnZShtZXNzYWdlKVxuICAgICAgc2V0SW5wdXRWYWx1ZSgnJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJjaGF0LWNvbXBvbmVudFwiPlxuICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImNvbm5lY3Rpb24tc3RhdHVzXCI+XG4gICAgICAgIFN0YXR1czoge2Nvbm5lY3Rpb25TdGF0dXN9XG4gICAgICA8L2Rpdj5cbiAgICAgIFxuICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cIm1lc3NhZ2VzLWNvbnRhaW5lclwiPlxuICAgICAgICB7bWVzc2FnZXMubWFwKG1zZyA9PiAoXG4gICAgICAgICAgPGRpdiBrZXk9e21zZy5pZH0gZGF0YS10ZXN0aWQ9e2BtZXNzYWdlLSR7bXNnLmlkfWB9PlxuICAgICAgICAgICAgPHN0cm9uZz57bXNnLmF1dGhvcn06PC9zdHJvbmc+IHttc2cuY29udGVudH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSl9XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cIm1lc3NhZ2UtaW5wdXQtY29udGFpbmVyXCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGRhdGEtdGVzdGlkPVwibWVzc2FnZS1pbnB1dFwiXG4gICAgICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XG4gICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbnB1dFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBvbktleVByZXNzPXsoZSkgPT4gZS5rZXkgPT09ICdFbnRlcicgJiYgaGFuZGxlU2VuZE1lc3NhZ2UoKX1cbiAgICAgICAgICBkaXNhYmxlZD17IWlzQ29ubmVjdGVkfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXtpc0Nvbm5lY3RlZCA/ICdUeXBlIGEgbWVzc2FnZS4uLicgOiAnQ29ubmVjdGluZy4uLid9XG4gICAgICAgIC8+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBkYXRhLXRlc3RpZD1cInNlbmQtYnV0dG9uXCJcbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTZW5kTWVzc2FnZX1cbiAgICAgICAgICBkaXNhYmxlZD17IWlzQ29ubmVjdGVkIHx8ICFpbnB1dFZhbHVlLnRyaW0oKX1cbiAgICAgICAgPlxuICAgICAgICAgIFNlbmRcbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG4vLyBNb2NrIGxpdmUgdXBkYXRlcyBjb21wb25lbnRcbmNvbnN0IE1vY2tMaXZlVXBkYXRlc0NvbXBvbmVudCA9ICh7IHNvY2tldCwgaXNDb25uZWN0ZWQgfTogYW55KSA9PiB7XG4gIGNvbnN0IFtwb3N0cywgc2V0UG9zdHNdID0gUmVhY3QudXNlU3RhdGU8YW55W10+KFtdKVxuICBjb25zdCBbbm90aWZpY2F0aW9ucywgc2V0Tm90aWZpY2F0aW9uc10gPSBSZWFjdC51c2VTdGF0ZTxhbnlbXT4oW10pXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNvY2tldCkgcmV0dXJuXG5cbiAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBkYXRhXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBldmVudC5kYXRhXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnbmV3X3Bvc3QnOlxuICAgICAgICAgICAgc2V0UG9zdHMocHJldiA9PiBbZGF0YS5wYXlsb2FkLCAuLi5wcmV2XSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAncG9zdF91cGRhdGVkJzpcbiAgICAgICAgICAgIHNldFBvc3RzKHByZXYgPT4gcHJldi5tYXAocG9zdCA9PiBcbiAgICAgICAgICAgICAgcG9zdC5pZCA9PT0gZGF0YS5wYXlsb2FkLmlkID8gZGF0YS5wYXlsb2FkIDogcG9zdFxuICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnbm90aWZpY2F0aW9uJzpcbiAgICAgICAgICAgIHNldE5vdGlmaWNhdGlvbnMocHJldiA9PiBbZGF0YS5wYXlsb2FkLCAuLi5wcmV2XSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBsaXZlIHVwZGF0ZTonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzb2NrZXQub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChzb2NrZXQub25tZXNzYWdlID09PSBoYW5kbGVNZXNzYWdlKSB7XG4gICAgICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9LCBbc29ja2V0XSlcblxuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJsaXZlLXVwZGF0ZXNcIj5cbiAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJsaXZlLXBvc3RzXCI+XG4gICAgICAgIHtwb3N0cy5tYXAocG9zdCA9PiAoXG4gICAgICAgICAgPGRpdiBrZXk9e3Bvc3QuaWR9IGRhdGEtdGVzdGlkPXtgbGl2ZS1wb3N0LSR7cG9zdC5pZH1gfT5cbiAgICAgICAgICAgIHtwb3N0LnRpdGxlfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuICAgICAgXG4gICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwibGl2ZS1ub3RpZmljYXRpb25zXCI+XG4gICAgICAgIHtub3RpZmljYXRpb25zLm1hcChub3RpZmljYXRpb24gPT4gKFxuICAgICAgICAgIDxkaXYga2V5PXtub3RpZmljYXRpb24uaWR9IGRhdGEtdGVzdGlkPXtgbm90aWZpY2F0aW9uLSR7bm90aWZpY2F0aW9uLmlkfWB9PlxuICAgICAgICAgICAge25vdGlmaWNhdGlvbi5tZXNzYWdlfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmRlc2NyaWJlKCdXZWJTb2NrZXQgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gICAgTW9ja1dlYlNvY2tldEluc3RhbmNlcy5sZW5ndGggPSAwXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0Nvbm5lY3Rpb24gTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnZXN0YWJsaXNoZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gb24gbW91bnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxNb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cInRlc3QtY29tcG9uZW50XCIgLz5cbiAgICAgICAgPC9Nb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICApXG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ3dlYnNvY2tldC1wcm92aWRlcicpKS50b0JlSW5UaGVEb2N1bWVudCgpXG5cbiAgICAgIC8vIFdhaXQgZm9yIGNvbm5lY3Rpb24gdG8gZXN0YWJsaXNoXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgLy8gQ29ubmVjdGlvbiBzaG91bGQgYmUgZXN0YWJsaXNoZWQgYXV0b21hdGljYWxseVxuICAgICAgICBleHBlY3QoTW9ja1dlYlNvY2tldENvbnN0cnVjdG9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnd3M6Ly9sb2NhbGhvc3Q6MzAwMScpXG4gICAgICB9LCB7IHRpbWVvdXQ6IDIwMCB9KVxuICAgIH0pXG5cbiAgICBpdCgnc2hvd3MgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPE1vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgICAgICA8TW9ja0NoYXRDb21wb25lbnQgLz5cbiAgICAgICAgPC9Nb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICApXG5cbiAgICAgIC8vIEluaXRpYWxseSBjb25uZWN0aW5nXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdjb25uZWN0aW9uLXN0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnU3RhdHVzOiBjb25uZWN0aW5nJylcblxuICAgICAgLy8gV2FpdCBmb3IgY29ubmVjdGlvbiB0byBvcGVuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnY29ubmVjdGlvbi1zdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ1N0YXR1czogY29ubmVjdGVkJylcbiAgICAgIH0sIHsgdGltZW91dDogMjAwIH0pXG4gICAgfSlcblxuICAgIGl0KCdoYW5kbGVzIGNvbm5lY3Rpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICh7IHNvY2tldCB9OiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSBSZWFjdC51c2VTdGF0ZSgnJylcblxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgIHNvY2tldC5vbmVycm9yID0gKCkgPT4gc2V0RXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkJylcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtzb2NrZXRdKVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIHtlcnJvciAmJiA8ZGl2IGRhdGEtdGVzdGlkPVwiY29ubmVjdGlvbi1lcnJvclwiPntlcnJvcn08L2Rpdj59XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8TW9ja1dlYlNvY2tldFByb3ZpZGVyPlxuICAgICAgICAgIDxUZXN0Q29tcG9uZW50IC8+XG4gICAgICAgIDwvTW9ja1dlYlNvY2tldFByb3ZpZGVyPlxuICAgICAgKVxuXG4gICAgICAvLyBXYWl0IGZvciBzb2NrZXQgdG8gYmUgY3JlYXRlZCwgdGhlbiBzaW11bGF0ZSBlcnJvclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gc2NyZWVuLmdldEJ5VGVzdElkKCd3ZWJzb2NrZXQtcHJvdmlkZXInKVxuICAgICAgICBleHBlY3QocHJvdmlkZXIpLnRvQmVJblRoZURvY3VtZW50KClcbiAgICAgIH0pXG5cbiAgICAgIC8vIFNpbXVsYXRlIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgd291bGQgYmUgdHJpZ2dlcmVkIGJ5IHRoZSBtb2NrIFdlYlNvY2tldFxuICAgICAgICBjb25zdCBtb2NrU29ja2V0ID0gbmV3IE1vY2tXZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjMwMDEnKVxuICAgICAgICBtb2NrU29ja2V0LnNpbXVsYXRlRXJyb3IoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ3JlY29ubmVjdHMgb24gY29ubmVjdGlvbiBsb3NzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICh7IHNvY2tldCwgY29ubmVjdCwgY29ubmVjdGlvblN0YXR1cyB9OiBhbnkpID0+IHtcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXR1cyA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgIXNvY2tldCkge1xuICAgICAgICAgICAgLy8gQXV0by1yZWNvbm5lY3QgbG9naWNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY29ubmVjdCwgMTAwMClcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtjb25uZWN0aW9uU3RhdHVzLCBzb2NrZXQsIGNvbm5lY3RdKVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImNvbm5lY3Rpb24tc3RhdHVzXCI+XG4gICAgICAgICAgICBTdGF0dXM6IHtjb25uZWN0aW9uU3RhdHVzfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPE1vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgICAgICA8VGVzdENvbXBvbmVudCAvPlxuICAgICAgICA8L01vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgIClcblxuICAgICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBjb25uZWN0aW9uXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnY29ubmVjdGlvbi1zdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ1N0YXR1czogY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIC8vIFNpbXVsYXRlIGNvbm5lY3Rpb24gbG9zc1xuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1NvY2tldCA9IG5ldyBNb2NrV2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDozMDAxJylcbiAgICAgICAgbW9ja1NvY2tldC5zaW11bGF0ZUNsb3NlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnUmVhbC10aW1lIENoYXQnLCAoKSA9PiB7XG4gICAgaXQoJ3NlbmRzIGFuZCByZWNlaXZlcyBjaGF0IG1lc3NhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdXNlciA9IHVzZXJFdmVudC5zZXR1cCgpXG4gICAgICBcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPE1vY2tXZWJTb2NrZXRQcm92aWRlcj5cbiAgICAgICAgICA8TW9ja0NoYXRDb21wb25lbnQgLz5cbiAgICAgICAgPC9Nb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICApXG5cbiAgICAgIC8vIFdhaXQgZm9yIGNvbm5lY3Rpb25cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdjb25uZWN0aW9uLXN0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnU3RhdHVzOiBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgLy8gVHlwZSBhbmQgc2VuZCBtZXNzYWdlXG4gICAgICBjb25zdCBpbnB1dCA9IHNjcmVlbi5nZXRCeVRlc3RJZCgnbWVzc2FnZS1pbnB1dCcpXG4gICAgICBjb25zdCBzZW5kQnV0dG9uID0gc2NyZWVuLmdldEJ5VGVzdElkKCdzZW5kLWJ1dHRvbicpXG5cbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dCwgJ0hlbGxvLCB3b3JsZCEnKVxuICAgICAgYXdhaXQgdXNlci5jbGljayhzZW5kQnV0dG9uKVxuXG4gICAgICAvLyBNZXNzYWdlIHNob3VsZCBiZSBzZW50IGFuZCBlY2hvZWQgYmFja1xuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzQ29udGFpbmVyID0gc2NyZWVuLmdldEJ5VGVzdElkKCdtZXNzYWdlcy1jb250YWluZXInKVxuICAgICAgICBleHBlY3QobWVzc2FnZXNDb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMClcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ3Rlc3R1c2VyOicpKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdIZWxsbywgd29ybGQhJykpLnRvQmVJblRoZURvY3VtZW50KClcbiAgICAgIH0pXG5cbiAgICAgIC8vIElucHV0IHNob3VsZCBiZSBjbGVhcmVkXG4gICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZVZhbHVlKCcnKVxuICAgIH0pXG5cbiAgICBpdCgnZGlzYWJsZXMgaW5wdXQgd2hlbiBkaXNjb25uZWN0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxNb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICAgICAgPE1vY2tDaGF0Q29tcG9uZW50IC8+XG4gICAgICAgIDwvTW9ja1dlYlNvY2tldFByb3ZpZGVyPlxuICAgICAgKVxuXG4gICAgICBjb25zdCBpbnB1dCA9IHNjcmVlbi5nZXRCeVRlc3RJZCgnbWVzc2FnZS1pbnB1dCcpXG4gICAgICBjb25zdCBzZW5kQnV0dG9uID0gc2NyZWVuLmdldEJ5VGVzdElkKCdzZW5kLWJ1dHRvbicpXG5cbiAgICAgIC8vIEluaXRpYWxseSBkaXNhYmxlZCB3aGlsZSBjb25uZWN0aW5nXG4gICAgICBleHBlY3QoaW5wdXQpLnRvQmVEaXNhYmxlZCgpXG4gICAgICBleHBlY3Qoc2VuZEJ1dHRvbikudG9CZURpc2FibGVkKClcblxuICAgICAgLy8gV2FpdCBmb3IgY29ubmVjdGlvblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChpbnB1dCkubm90LnRvQmVEaXNhYmxlZCgpXG4gICAgICAgIGV4cGVjdChzZW5kQnV0dG9uKS50b0JlRGlzYWJsZWQoKSAvLyBTdGlsbCBkaXNhYmxlZCBkdWUgdG8gZW1wdHkgaW5wdXRcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGl0KCdoYW5kbGVzIG1lc3NhZ2Ugc2VuZGluZyB3aXRoIEVudGVyIGtleScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKVxuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxNb2NrV2ViU29ja2V0UHJvdmlkZXI+XG4gICAgICAgICAgPE1vY2tDaGF0Q29tcG9uZW50IC8+XG4gICAgICAgIDwvTW9ja1dlYlNvY2tldFByb3ZpZGVyPlxuICAgICAgKVxuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnY29ubmVjdGlvbi1zdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ1N0YXR1czogY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGlucHV0ID0gc2NyZWVuLmdldEJ5VGVzdElkKCdtZXNzYWdlLWlucHV0JylcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dCwgJ1Rlc3QgbWVzc2FnZXtlbnRlcn0nKVxuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1Rlc3QgbWVzc2FnZScpKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0xpdmUgVXBkYXRlcycsICgpID0+IHtcbiAgICBpdCgncmVjZWl2ZXMgYW5kIGRpc3BsYXlzIG5ldyBwb3N0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB0ZXN0U29ja2V0OiBNb2NrV2ViU29ja2V0IHwgbnVsbCA9IG51bGxcbiAgICAgIFxuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IFJlYWN0LnVzZVN0YXRlPE1vY2tXZWJTb2NrZXQgfCBudWxsPihudWxsKVxuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCB3cyA9IG5ldyBNb2NrV2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDozMDAxJylcbiAgICAgICAgICB0ZXN0U29ja2V0ID0gd3NcbiAgICAgICAgICBzZXRTb2NrZXQod3MpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBmb3IgY29ubmVjdGlvbiB0byBvcGVuLCB0aGVuIHNpbXVsYXRlIG1lc3NhZ2VcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBNb2NrV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICAgICAgd3Muc2ltdWxhdGVNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbmV3X3Bvc3QnLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAnMScsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogJ0xpdmUgUG9zdCBVcGRhdGUnLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogJ1Rlc3QgY29udGVudCcsXG4gICAgICAgICAgICAgICAgICBhdXRob3I6ICd0ZXN0dXNlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTApXG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIHJldHVybiA8TW9ja0xpdmVVcGRhdGVzQ29tcG9uZW50IHNvY2tldD17c29ja2V0fSBpc0Nvbm5lY3RlZD17dHJ1ZX0gLz5cbiAgICAgIH1cblxuICAgICAgcmVuZGVyKDxUZXN0Q29tcG9uZW50IC8+KVxuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0xpdmUgUG9zdCBVcGRhdGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgICAgfSwgeyB0aW1lb3V0OiAyMDAwIH0pXG4gICAgfSlcblxuICAgIGl0KCdyZWNlaXZlcyBhbmQgZGlzcGxheXMgbm90aWZpY2F0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB0ZXN0U29ja2V0OiBNb2NrV2ViU29ja2V0IHwgbnVsbCA9IG51bGxcbiAgICAgIFxuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IFJlYWN0LnVzZVN0YXRlPE1vY2tXZWJTb2NrZXQgfCBudWxsPihudWxsKVxuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCB3cyA9IG5ldyBNb2NrV2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDozMDAxJylcbiAgICAgICAgICB0ZXN0U29ja2V0ID0gd3NcbiAgICAgICAgICBzZXRTb2NrZXQod3MpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBmb3IgY29ubmVjdGlvbiB0byBvcGVuLCB0aGVuIHNpbXVsYXRlIG1lc3NhZ2VcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBNb2NrV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICAgICAgd3Muc2ltdWxhdGVNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbm90aWZpY2F0aW9uJyxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICBpZDogJzEnLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ05ldyBub3RpZmljYXRpb24gcmVjZWl2ZWQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDUwKVxuICAgICAgICB9LCBbXSlcblxuICAgICAgICByZXR1cm4gPE1vY2tMaXZlVXBkYXRlc0NvbXBvbmVudCBzb2NrZXQ9e3NvY2tldH0gaXNDb25uZWN0ZWQ9e3RydWV9IC8+XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcig8VGVzdENvbXBvbmVudCAvPilcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdOZXcgbm90aWZpY2F0aW9uIHJlY2VpdmVkJykpLnRvQmVJblRoZURvY3VtZW50KClcbiAgICAgIH0sIHsgdGltZW91dDogMjAwMCB9KVxuICAgIH0pXG5cbiAgICBpdCgndXBkYXRlcyBleGlzdGluZyBwb3N0cyB3aGVuIG1vZGlmaWVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHRlc3RTb2NrZXQ6IE1vY2tXZWJTb2NrZXQgfCBudWxsID0gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBbc29ja2V0LCBzZXRTb2NrZXRdID0gUmVhY3QudXNlU3RhdGU8TW9ja1dlYlNvY2tldCB8IG51bGw+KG51bGwpXG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHdzID0gbmV3IE1vY2tXZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjMwMDEnKVxuICAgICAgICAgIHRlc3RTb2NrZXQgPSB3c1xuICAgICAgICAgIHNldFNvY2tldCh3cylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGZvciBjb25uZWN0aW9uIHRvIG9wZW4sIHRoZW4gc2ltdWxhdGUgbWVzc2FnZXNcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBNb2NrV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICAgICAgLy8gRmlyc3QsIGFkZCBhIHBvc3RcbiAgICAgICAgICAgICAgd3Muc2ltdWxhdGVNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbmV3X3Bvc3QnLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAnMScsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogJ09yaWdpbmFsIFRpdGxlJyxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdPcmlnaW5hbCBjb250ZW50JyxcbiAgICAgICAgICAgICAgICAgIGF1dGhvcjogJ3Rlc3R1c2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFRoZW4gdXBkYXRlIGl0XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdzLnNpbXVsYXRlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAncG9zdF91cGRhdGVkJyxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdVcGRhdGVkIFRpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1VwZGF0ZWQgY29udGVudCcsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcjogJ3Rlc3R1c2VyJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0sIDEwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDUwKVxuICAgICAgICB9LCBbXSlcblxuICAgICAgICByZXR1cm4gPE1vY2tMaXZlVXBkYXRlc0NvbXBvbmVudCBzb2NrZXQ9e3NvY2tldH0gaXNDb25uZWN0ZWQ9e3RydWV9IC8+XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcig8VGVzdENvbXBvbmVudCAvPilcblxuICAgICAgLy8gV2FpdCBmb3Igb3JpZ2luYWwgcG9zdFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdPcmlnaW5hbCBUaXRsZScpKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICB9LCB7IHRpbWVvdXQ6IDIwMDAgfSlcblxuICAgICAgLy8gV2FpdCBmb3IgdXBkYXRlXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1VwZGF0ZWQgVGl0bGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdPcmlnaW5hbCBUaXRsZScpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgICAgfSwgeyB0aW1lb3V0OiAxMDAwIH0pXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ2hhbmRsZXMgbWFsZm9ybWVkIFdlYlNvY2tldCBtZXNzYWdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpXG4gICAgICBcbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IFtzb2NrZXQsIHNldFNvY2tldF0gPSBSZWFjdC51c2VTdGF0ZTxNb2NrV2ViU29ja2V0IHwgbnVsbD4obnVsbClcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3MgPSBuZXcgTW9ja1dlYlNvY2tldCgnd3M6Ly9sb2NhbGhvc3Q6MzAwMScpXG4gICAgICAgICAgc2V0U29ja2V0KHdzKVxuICAgICAgICAgIFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IE1vY2tXZWJTb2NrZXQuT1BFTiAmJiB3cy5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgLy8gU2VuZCBtYWxmb3JtZWQgSlNPTlxuICAgICAgICAgICAgICB3cy5vbm1lc3NhZ2UobmV3IE1lc3NhZ2VFdmVudCgnbWVzc2FnZScsIHsgXG4gICAgICAgICAgICAgICAgZGF0YTogJ2ludmFsaWQganNvbicgXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDUwKVxuICAgICAgICB9LCBbXSlcblxuICAgICAgICByZXR1cm4gPE1vY2tMaXZlVXBkYXRlc0NvbXBvbmVudCBzb2NrZXQ9e3NvY2tldH0gaXNDb25uZWN0ZWQ9e3RydWV9IC8+XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcig8VGVzdENvbXBvbmVudCAvPilcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnRmFpbGVkIHRvIHBhcnNlIGxpdmUgdXBkYXRlOicsXG4gICAgICAgICAgZXhwZWN0LmFueShFcnJvcilcbiAgICAgICAgKVxuICAgICAgfSwgeyB0aW1lb3V0OiAxMDAwIH0pXG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKVxuICAgIH0pXG5cbiAgICBpdCgnZ3JhY2VmdWxseSBoYW5kbGVzIHVua25vd24gbWVzc2FnZSB0eXBlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IFtzb2NrZXQsIHNldFNvY2tldF0gPSBSZWFjdC51c2VTdGF0ZTxNb2NrV2ViU29ja2V0IHwgbnVsbD4obnVsbClcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3MgPSBuZXcgTW9ja1dlYlNvY2tldCgnd3M6Ly9sb2NhbGhvc3Q6MzAwMScpXG4gICAgICAgICAgc2V0U29ja2V0KHdzKVxuICAgICAgICAgIFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IE1vY2tXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgICB3cy5zaW11bGF0ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd1bmtub3duX3R5cGUnLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgZGF0YTogJ3Rlc3QnIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCA1MClcbiAgICAgICAgfSwgW10pXG5cbiAgICAgICAgcmV0dXJuIDxNb2NrTGl2ZVVwZGF0ZXNDb21wb25lbnQgc29ja2V0PXtzb2NrZXR9IGlzQ29ubmVjdGVkPXt0cnVlfSAvPlxuICAgICAgfVxuXG4gICAgICByZW5kZXIoPFRlc3RDb21wb25lbnQgLz4pXG5cbiAgICAgIC8vIFNob3VsZCBub3QgY3Jhc2ggb3Igc2hvdyBhbnkgZXJyb3JcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdsaXZlLXVwZGF0ZXMnKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnaGFuZGxlcyBoaWdoLWZyZXF1ZW5jeSBtZXNzYWdlcyB3aXRob3V0IHBlcmZvcm1hbmNlIGlzc3VlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IFtzb2NrZXQsIHNldFNvY2tldF0gPSBSZWFjdC51c2VTdGF0ZTxNb2NrV2ViU29ja2V0IHwgbnVsbD4obnVsbClcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3MgPSBuZXcgTW9ja1dlYlNvY2tldCgnd3M6Ly9sb2NhbGhvc3Q6MzAwMScpXG4gICAgICAgICAgc2V0U29ja2V0KHdzKVxuICAgICAgICAgIFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IE1vY2tXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgICAvLyBTZW5kIG1hbnkgbWVzc2FnZXMgcmFwaWRseVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgICAgICB3cy5zaW11bGF0ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ25vdGlmaWNhdGlvbicsXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBNZXNzYWdlICR7aX1gLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5mbydcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTApXG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIHJldHVybiA8TW9ja0xpdmVVcGRhdGVzQ29tcG9uZW50IHNvY2tldD17c29ja2V0fSBpc0Nvbm5lY3RlZD17dHJ1ZX0gLz5cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIFxuICAgICAgcmVuZGVyKDxUZXN0Q29tcG9uZW50IC8+KVxuXG4gICAgICAvLyBXYWl0IGZvciBtZXNzYWdlcyB0byBiZSBwcm9jZXNzZWRcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5VGVzdElkKC9ub3RpZmljYXRpb24tLykubGVuZ3RoKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDEwKVxuICAgICAgfSwgeyB0aW1lb3V0OiAzMDAwIH0pXG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lXG5cbiAgICAgIC8vIFNob3VsZCBwcm9jZXNzIG1lc3NhZ2VzIHJlYXNvbmFibHkgcXVpY2tseVxuICAgICAgZXhwZWN0KHByb2Nlc3NpbmdUaW1lKS50b0JlTGVzc1RoYW4oMzAwMClcbiAgICB9KVxuICB9KVxufSlcbiJdLCJuYW1lcyI6WyJNb2NrV2ViU29ja2V0SW5zdGFuY2VzIiwiTW9ja1dlYlNvY2tldCIsIkNPTk5FQ1RJTkciLCJPUEVOIiwiQ0xPU0lORyIsIkNMT1NFRCIsInVybCIsInJlYWR5U3RhdGUiLCJvbm9wZW4iLCJvbmNsb3NlIiwib25tZXNzYWdlIiwib25lcnJvciIsInB1c2giLCJzZXRUaW1lb3V0IiwiRXZlbnQiLCJzZW5kIiwiZGF0YSIsIkVycm9yIiwiTWVzc2FnZUV2ZW50IiwiY2xvc2UiLCJDbG9zZUV2ZW50Iiwic2ltdWxhdGVNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsInNpbXVsYXRlRXJyb3IiLCJzaW11bGF0ZUNsb3NlIiwiTW9ja1dlYlNvY2tldENvbnN0cnVjdG9yIiwiamVzdCIsImZuIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiZ2xvYmFsIiwiV2ViU29ja2V0IiwiTW9ja1dlYlNvY2tldFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzb2NrZXQiLCJzZXRTb2NrZXQiLCJSZWFjdCIsInVzZVN0YXRlIiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImNvbm5lY3Rpb25TdGF0dXMiLCJzZXRDb25uZWN0aW9uU3RhdHVzIiwiY29ubmVjdCIsInVzZUNhbGxiYWNrIiwid3MiLCJ1c2VFZmZlY3QiLCJkaXNjb25uZWN0Iiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwiY29udGV4dFZhbHVlIiwiZGl2IiwiZGF0YS10ZXN0aWQiLCJDaGlsZHJlbiIsIm1hcCIsImNoaWxkIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJNb2NrQ2hhdENvbXBvbmVudCIsIm1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJpbnB1dFZhbHVlIiwic2V0SW5wdXRWYWx1ZSIsImhhbmRsZU1lc3NhZ2UiLCJldmVudCIsInBhcnNlIiwidHlwZSIsInByZXYiLCJwYXlsb2FkIiwiZXJyb3IiLCJjb25zb2xlIiwiaGFuZGxlU2VuZE1lc3NhZ2UiLCJ0cmltIiwiaWQiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJjb250ZW50IiwiYXV0aG9yIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJtc2ciLCJzdHJvbmciLCJpbnB1dCIsInZhbHVlIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0Iiwib25LZXlQcmVzcyIsImtleSIsImRpc2FibGVkIiwicGxhY2Vob2xkZXIiLCJidXR0b24iLCJvbkNsaWNrIiwiTW9ja0xpdmVVcGRhdGVzQ29tcG9uZW50IiwicG9zdHMiLCJzZXRQb3N0cyIsIm5vdGlmaWNhdGlvbnMiLCJzZXROb3RpZmljYXRpb25zIiwicG9zdCIsInRpdGxlIiwibm90aWZpY2F0aW9uIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsImxlbmd0aCIsIml0IiwicmVuZGVyIiwiZXhwZWN0Iiwic2NyZWVuIiwiZ2V0QnlUZXN0SWQiLCJ0b0JlSW5UaGVEb2N1bWVudCIsIndhaXRGb3IiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInRpbWVvdXQiLCJ0b0hhdmVUZXh0Q29udGVudCIsIlRlc3RDb21wb25lbnQiLCJzZXRFcnJvciIsInByb3ZpZGVyIiwiYWN0IiwibW9ja1NvY2tldCIsInVzZXIiLCJ1c2VyRXZlbnQiLCJzZXR1cCIsInNlbmRCdXR0b24iLCJjbGljayIsIm1lc3NhZ2VzQ29udGFpbmVyIiwidG9CZUdyZWF0ZXJUaGFuIiwiZ2V0QnlUZXh0IiwidG9IYXZlVmFsdWUiLCJ0b0JlRGlzYWJsZWQiLCJub3QiLCJ0ZXN0U29ja2V0IiwicXVlcnlCeVRleHQiLCJjb25zb2xlU3B5Iiwic3B5T24iLCJhbnkiLCJtb2NrUmVzdG9yZSIsImkiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsImdldEFsbEJ5VGVzdElkIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsImVuZFRpbWUiLCJwcm9jZXNzaW5nVGltZSIsInRvQmVMZXNzVGhhbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7K0RBQWtCO3dCQUNzQjtrRUFFbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR3RCLGlCQUFpQjtBQUNqQixNQUFNQSx5QkFBMEMsRUFBRTtBQUVsRCxNQUFNQzs7YUFDR0MsYUFBYTs7O2FBQ2JDLE9BQU87OzthQUNQQyxVQUFVOzs7YUFDVkMsU0FBUzs7SUFTaEIsWUFBWUMsR0FBVyxDQUFFO2FBTnpCQyxhQUFxQk4sY0FBY0MsVUFBVTthQUM3Q00sU0FBMEM7YUFDMUNDLFVBQWdEO2FBQ2hEQyxZQUFvRDthQUNwREMsVUFBMkM7UUFHekMsSUFBSSxDQUFDTCxHQUFHLEdBQUdBO1FBQ1hOLHVCQUF1QlksSUFBSSxDQUFDLElBQUk7UUFDaEMsOEJBQThCO1FBQzlCQyxXQUFXO1lBQ1QsSUFBSSxDQUFDTixVQUFVLEdBQUdOLGNBQWNFLElBQUk7WUFDcEMsSUFBSSxJQUFJLENBQUNLLE1BQU0sRUFBRTtnQkFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQyxJQUFJTSxNQUFNO1lBQ3hCO1FBQ0YsR0FBRztJQUNMO0lBRUFDLEtBQUtDLElBQVksRUFBRTtRQUNqQixJQUFJLElBQUksQ0FBQ1QsVUFBVSxLQUFLTixjQUFjRSxJQUFJLEVBQUU7WUFDMUMsTUFBTSxJQUFJYyxNQUFNO1FBQ2xCO1FBQ0Esd0JBQXdCO1FBQ3hCSixXQUFXO1lBQ1QsSUFBSSxJQUFJLENBQUNILFNBQVMsRUFBRTtnQkFDbEIsSUFBSSxDQUFDQSxTQUFTLENBQUMsSUFBSVEsYUFBYSxXQUFXO29CQUFFRjtnQkFBSztZQUNwRDtRQUNGLEdBQUc7SUFD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